syntax = "proto3";

package envoy.api.v2.filter.http;

option java_package = "io.envoyproxy.envoy.api.v2.filter.http";
option java_outer_classname = "TransformationFilterProto";
option java_multiple_files = true;
option go_package = "transformation";

import "google/protobuf/empty.proto";
import "validate/validate.proto";

import "envoy/config/route/v3/route_components.proto";
import "envoy/type/matcher/v3/string.proto";

message FilterTransformations {
  // Specifies transformations based on the route matches. The first matched transformation will be
  // applied. If there are overlapped match conditions, please put the most specific match first.
  repeated TransformationRule transformations = 1;

  // Only RouteTransformations.Transformations with matching stage will be used with this filter.
  uint32 stage = 2 [(validate.rules).uint32 = {lte: 10}];
}

message TransformationRule {
  // The route matching parameter. Only when the match is satisfied, the "requires" field will
  // apply.
  //
  // For example: following match will match all requests.
  //
  // .. code-block:: yaml
  //
  //    match:
  //      prefix: /
  //
  envoy.config.route.v3.RouteMatch match = 1 [(validate.rules).message = {required: true}];

  message Transformations {
    Transformation request_transformation = 1;
    Transformation response_transformation = 2;
     // clear the route cache if the request transformation was applied
    bool clear_route_cache = 3;
  }
  // transformation to perform 
  Transformations route_transformations = 2;
}

message RouteTransformations {
  // deprecated. Use transformations[].request_match.request_transformation instead.
  Transformation request_transformation = 1 [deprecated=true];
  // deprecated. Use transformations[].request_match.response_transformation instead.
  Transformation response_transformation = 2 [deprecated=true];
  // deprecated. Use transformations[].request_match.clear_route_cache instead.
  bool clear_route_cache = 3 [deprecated=true];

  message RouteTransformation {
    // Stage number
    uint32 stage = 1 [(validate.rules).uint32 = {lte: 10}];

    message RequestMatch {
      // if no match is specified, will match all
      envoy.config.route.v3.RouteMatch match = 1;
      // transformation to perform 
      Transformation request_transformation = 2;
      Transformation response_transformation = 3;
      // clear the route cache if the request transformation was applied
      bool clear_route_cache = 4;
    }

    message ResponseMatch {
      ResponseMatcher match = 1;
      // transformation to perform 
      Transformation response_transformation = 2;
    }

    oneof match {
      option (validate.required) = true;
      RequestMatch request_match = 2;
      ResponseMatch response_match = 3;
    }
  }

  repeated RouteTransformation transformations = 4;
}


message ResponseMatcher {
  // Specifies a set of headers that the route should match on. The router will
  // check the response headers against all the specified headers in the route
  // config. A match will happen if all the headers in the route are present in
  // the request with the same values (or based on presence if the value field
  // is not in the config).
  repeated envoy.config.route.v3.HeaderMatcher headers = 1;

  // Only match responses with non empty response code details (this usually implies a local reply).
  envoy.type.matcher.v3.StringMatcher response_code_details = 2;
}

message ResponseTransformationRule {
  ResponseMatcher match = 1;
  // transformation to perform 
  Transformation response_transformation = 2;
}

// [#proto-status: experimental]
message Transformation {
  // Template is in the transformed request language domain
  // currently both are JSON
  oneof transformation_type {
    TransformationTemplate transformation_template = 1;
    HeaderBodyTransform header_body_transform = 2;
  }
}

message Extraction {
  oneof source {
    string header = 1;
    google.protobuf.Empty body = 4;
  }
  // what information to extract. if extraction fails the result is
  // an empty value.
  string regex = 2;
  uint32 subgroup = 3;
}

message TransformationTemplate {
  bool advanced_templates = 1;
  // Extractors are in the original request language domain
  map<string, Extraction> extractors = 2;

  map<string, InjaTemplate> headers = 3;

  oneof body_transformation {
    InjaTemplate body = 4;
    Passthrough passthrough = 5;
    MergeExtractorsToBody merge_extractors_to_body = 6;
  }

  enum RequestBodyParse {
    ParseAsJson = 0;
    DontParse = 1;
  }
  RequestBodyParse parse_body_behavior = 7;
  bool ignore_error_on_parse = 8;

  message DynamicMetadataValue {
    // optional. if not set filter namespace will be used.
    string metadata_namespace = 1;
    string key = 2 [(validate.rules).string = {min_bytes: 1}];
    InjaTemplate value = 3; 
  }
  repeated DynamicMetadataValue dynamic_metadata_values = 9;

}

/*
custom functions:
header_value(name) -> from the original headers
extracted_value(name, index) -> from the extracted values
*/
message InjaTemplate { string text = 1; }

message Passthrough {}

message MergeExtractorsToBody {}

message HeaderBodyTransform {}

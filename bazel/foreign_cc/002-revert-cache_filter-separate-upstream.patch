From bd95528ab79e2c0513aa88ffd3fccb11afe744fc Mon Sep 17 00:00:00 2001
From: Andy Fong <andy.fong@solo.io>
Date: Mon, 12 Jan 2026 09:02:56 -0500
Subject: [PATCH] Revert "[cache_filter] Separate upstream from downstream
 (#36309)"

This reverts commit 55e23547a5bf8088a002d0a71a3fa983adf7e046.

Signed-off-by: Andy Fong <andy.fong@solo.io>
---
 docs/root/_static/cache-filter-chain.svg      | Bin 104052 -> 0 bytes
 .../http/http_filters/cache_filter.rst        |  14 +-
 source/extensions/filters/http/cache/BUILD    |  11 +-
 .../filters/http/cache/cache_filter.cc        | 323 ++++--
 .../filters/http/cache/cache_filter.h         |  87 +-
 .../http/cache/cache_filter_logging_info.cc   |   4 +-
 .../http/cache/cache_filter_logging_info.h    |   8 +-
 .../filters/http/cache/cache_insert_queue.cc  |  61 +-
 .../filters/http/cache/cache_insert_queue.h   |  15 +-
 .../filters/http/cache/filter_state.h         |  36 -
 .../filters/http/cache/http_cache.h           |   4 +-
 .../filters/http/cache/upstream_request.cc    | 272 -----
 .../filters/http/cache/upstream_request.h     |  84 --
 .../file_system_http_cache.cc                 |  11 +-
 .../file_system_http_cache.h                  |   4 +-
 .../file_system_http_cache/insert_context.cc  |   5 +-
 .../file_system_http_cache/insert_context.h   |  10 +-
 .../simple_http_cache/simple_http_cache.cc    |  10 +-
 .../simple_http_cache/simple_http_cache.h     |   4 +-
 .../cache/cache_filter_logging_info_test.cc   |   4 +-
 .../filters/http/cache/cache_filter_test.cc   | 957 ++++++++++--------
 test/extensions/filters/http/cache/mocks.h    |  53 +-
 .../file_system_http_cache_test.cc            |   1 +
 23 files changed, 904 insertions(+), 1074 deletions(-)
 delete mode 100644 docs/root/_static/cache-filter-chain.svg
 delete mode 100644 source/extensions/filters/http/cache/filter_state.h
 delete mode 100644 source/extensions/filters/http/cache/upstream_request.cc
 delete mode 100644 source/extensions/filters/http/cache/upstream_request.h

diff --git docs/root/_static/cache-filter-chain.svg docs/root/_static/cache-filter-chain.svg
deleted file mode 100644
index fe54227819ffd55362143a3b63479ed2c6f21cc2..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 104052
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%0Dm$PLVYb$s
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

diff --git docs/root/configuration/http/http_filters/cache_filter.rst docs/root/configuration/http/http_filters/cache_filter.rst
index 1edd5a146e..618a89544a 100644
--- docs/root/configuration/http/http_filters/cache_filter.rst
+++ docs/root/configuration/http/http_filters/cache_filter.rst
@@ -7,24 +7,12 @@ Cache filter
 * :ref:`v3 API reference <envoy_v3_api_msg_extensions.filters.http.cache.v3.CacheConfig>`
 * :ref:`v3 SimpleHTTPCache API reference <envoy_v3_api_msg_extensions.http.cache.simple_http_cache.v3.SimpleHttpCacheConfig>`
 * This filter doesn't support virtual host-specific configurations.
-* When the cache is enabled, cacheable requests are only sent through filters in the
-  :ref:`upstream_http_filters <envoy_v3_api_field_extensions.filters.http.router.v3.Router.upstream_http_filters>`
-  chain and *not* through any filters in the regular filter chain that are further
-  upstream than the cache filter, while non-cacheable requests still go through the
-  listener filter chain. It is therefore recommended for consistency that only the
-  router filter should be further upstream in the listener filter chain than the
-  cache filter.
-
-.. image:: /_static/cache-filter-chain.svg
-   :width: 80%
-   :align: center
 
 The HTTP Cache filter implements most of the complexity of HTTP caching semantics.
 
 For HTTP Requests:
 
-* HTTP Cache respects request's ``Cache-Control`` directive. For example, if request comes with ``Cache-Control: no-store`` the request won't be cached, unless
-  :ref:`ignore_request_cache_control_header <envoy_v3_api_field_extensions.filters.http.cache.v3.CacheConfig.ignore_request_cache_control_header>` is true.
+* HTTP Cache respects request's ``Cache-Control`` directive. For example, if request comes with ``Cache-Control: no-store`` the request won't be cached.
 * HTTP Cache wont store HTTP HEAD Requests.
 
 For HTTP Responses:
diff --git source/extensions/filters/http/cache/BUILD source/extensions/filters/http/cache/BUILD
index c8bb391d51..9107e06fc5 100644
--- source/extensions/filters/http/cache/BUILD
+++ source/extensions/filters/http/cache/BUILD
@@ -14,15 +14,8 @@ envoy_extension_package()
 
 envoy_cc_library(
     name = "cache_filter_lib",
-    srcs = [
-        "cache_filter.cc",
-        "upstream_request.cc",
-    ],
-    hdrs = [
-        "cache_filter.h",
-        "filter_state.h",
-        "upstream_request.h",
-    ],
+    srcs = ["cache_filter.cc"],
+    hdrs = ["cache_filter.h"],
     deps = [
         ":cache_custom_headers",
         ":cache_entry_utils_lib",
diff --git source/extensions/filters/http/cache/cache_filter.cc source/extensions/filters/http/cache/cache_filter.cc
index 9560d40e74..79c6b0ecb9 100644
--- source/extensions/filters/http/cache/cache_filter.cc
+++ source/extensions/filters/http/cache/cache_filter.cc
@@ -9,7 +9,6 @@
 #include "source/extensions/filters/http/cache/cache_entry_utils.h"
 #include "source/extensions/filters/http/cache/cache_filter_logging_info.h"
 #include "source/extensions/filters/http/cache/cacheability_utils.h"
-#include "source/extensions/filters/http/cache/upstream_request.h"
 
 #include "absl/memory/memory.h"
 #include "absl/strings/str_cat.h"
@@ -21,6 +20,10 @@ namespace HttpFilters {
 namespace Cache {
 
 namespace {
+inline bool isResponseNotModified(const Http::ResponseHeaderMap& response_headers) {
+  return Http::Utility::getResponseStatus(response_headers) == enumToInt(Http::Code::NotModified);
+}
+
 // This value is only used if there is no bufferLimit on the stream;
 // without *some* constraint here, a very large chunk can be requested and
 // attempt to load into a memory buffer.
@@ -42,8 +45,7 @@ CacheFilterConfig::CacheFilterConfig(
     const envoy::extensions::filters::http::cache::v3::CacheConfig& config,
     Server::Configuration::CommonFactoryContext& context)
     : vary_allow_list_(config.allowed_vary_headers(), context), time_source_(context.timeSource()),
-      ignore_request_cache_control_header_(config.ignore_request_cache_control_header()),
-      cluster_manager_(context.clusterManager()) {}
+      ignore_request_cache_control_header_(config.ignore_request_cache_control_header()) {}
 
 CacheFilter::CacheFilter(std::shared_ptr<const CacheFilterConfig> config,
                          std::shared_ptr<HttpCache> http_cache)
@@ -54,41 +56,19 @@ void CacheFilter::onDestroy() {
   if (lookup_ != nullptr) {
     lookup_->onDestroy();
   }
-  if (upstream_request_ != nullptr) {
-    upstream_request_->disconnectFilter();
-    upstream_request_ = nullptr;
+  if (insert_queue_ != nullptr) {
+    // The filter can complete and be destroyed while there is still data being
+    // written to the cache. In this case the filter hands ownership of the
+    // queue to itself, which cancels all the callbacks to the filter, but allows
+    // the queue to complete any write operations before deleting itself.
+    //
+    // In the case that the queue is already empty, or in a state which cannot
+    // complete, setSelfOwned will provoke the queue to abort the write operation.
+    insert_queue_->setSelfOwned(std::move(insert_queue_));
+    insert_queue_.reset();
   }
 }
 
-void CacheFilter::sendUpstreamRequest(Http::RequestHeaderMap& request_headers) {
-  Router::RouteConstSharedPtr route = decoder_callbacks_->route();
-  const Router::RouteEntry* route_entry = (route == nullptr) ? nullptr : route->routeEntry();
-  if (route_entry == nullptr) {
-    return sendNoRouteResponse();
-  }
-  Upstream::ThreadLocalCluster* thread_local_cluster =
-      config_->clusterManager().getThreadLocalCluster(route_entry->clusterName());
-  if (thread_local_cluster == nullptr) {
-    return sendNoClusterResponse(route_entry->clusterName());
-  }
-  upstream_request_ =
-      UpstreamRequest::create(this, std::move(lookup_), std::move(lookup_result_), cache_,
-                              thread_local_cluster->httpAsyncClient(), config_->upstreamOptions());
-  upstream_request_->sendHeaders(request_headers);
-}
-
-void CacheFilter::sendNoRouteResponse() {
-  decoder_callbacks_->sendLocalReply(Http::Code::NotFound, "", nullptr, absl::nullopt,
-                                     "cache_no_route");
-}
-
-void CacheFilter::sendNoClusterResponse(absl::string_view cluster_name) {
-  ENVOY_STREAM_LOG(debug, "upstream cluster '{}' was not available to cache", *decoder_callbacks_,
-                   cluster_name);
-  decoder_callbacks_->sendLocalReply(Http::Code::ServiceUnavailable, "", nullptr, absl::nullopt,
-                                     "cache_no_cluster");
-}
-
 void CacheFilter::onStreamComplete() {
   LookupStatus lookup_status = lookupStatus();
   InsertStatus insert_status = insertStatus();
@@ -137,16 +117,9 @@ Http::FilterHeadersStatus CacheFilter::decodeHeaders(Http::RequestHeaderMap& hea
   return Http::FilterHeadersStatus::StopAllIterationAndWatermark;
 }
 
-void CacheFilter::onUpstreamRequestComplete() { upstream_request_ = nullptr; }
-
-void CacheFilter::onUpstreamRequestReset() {
-  upstream_request_ = nullptr;
-  decoder_callbacks_->sendLocalReply(Http::Code::ServiceUnavailable, "", nullptr, absl::nullopt,
-                                     "cache_upstream_reset");
-}
-
-Http::FilterHeadersStatus CacheFilter::encodeHeaders(Http::ResponseHeaderMap& headers, bool) {
-  if (filter_state_ == FilterState::ServingFromCache) {
+Http::FilterHeadersStatus CacheFilter::encodeHeaders(Http::ResponseHeaderMap& headers,
+                                                     bool end_stream) {
+  if (filter_state_ == FilterState::DecodeServingFromCache) {
     // This call was invoked during decoding by decoder_callbacks_->encodeHeaders because a fresh
     // cached response was found and is being added to the encoding stream -- ignore it.
     return Http::FilterHeadersStatus::Continue;
@@ -165,16 +138,96 @@ Http::FilterHeadersStatus CacheFilter::encodeHeaders(Http::ResponseHeaderMap& he
     ENVOY_BUG(Http::Utility::getResponseStatus(headers) !=
                   Envoy::enumToInt(Http::Code::RequestTimeout),
               "Request timed out while cache lookup was outstanding.");
-    // Cancel the lookup since it's now not useful.
-    lookup_->onDestroy();
-    lookup_ = nullptr;
+    filter_state_ = FilterState::NotServingFromCache;
     return Http::FilterHeadersStatus::Continue;
   }
 
-  IS_ENVOY_BUG("encodeHeaders should not be called except under the conditions handled above");
+  if (filter_state_ == FilterState::ValidatingCachedResponse && isResponseNotModified(headers)) {
+    processSuccessfulValidation(headers);
+    // Stop the encoding stream until the cached response is fetched & added to the encoding stream.
+    if (is_head_request_) {
+      // Return since HEAD requests are not cached
+      return Http::FilterHeadersStatus::Continue;
+    } else {
+      return Http::FilterHeadersStatus::StopIteration;
+    }
+  }
+
+  // Either a cache miss or a cache entry that is no longer valid.
+  // Check if the new response can be cached.
+  if (request_allows_inserts_ && !is_head_request_ &&
+      CacheabilityUtils::isCacheableResponse(headers, config_->varyAllowList())) {
+    ENVOY_STREAM_LOG(debug, "CacheFilter::encodeHeaders inserting headers", *encoder_callbacks_);
+    auto insert_context = cache_->makeInsertContext(std::move(lookup_), *encoder_callbacks_);
+    if (insert_context != nullptr) {
+      // The callbacks passed to CacheInsertQueue are all called through the dispatcher,
+      // so they're thread-safe. During CacheFilter::onDestroy the queue is given ownership
+      // of itself and all the callbacks are cancelled, so they are also filter-destruction-safe.
+      insert_queue_ =
+          std::make_unique<CacheInsertQueue>(cache_, *encoder_callbacks_, std::move(insert_context),
+                                             // Cache aborted callback.
+                                             [this]() {
+                                               insert_queue_ = nullptr;
+                                               insert_status_ = InsertStatus::InsertAbortedByCache;
+                                             });
+      // Add metadata associated with the cached response. Right now this is only response_time;
+      const ResponseMetadata metadata = {config_->timeSource().systemTime()};
+      insert_queue_->insertHeaders(headers, metadata, end_stream);
+    }
+    if (end_stream) {
+      insert_status_ = InsertStatus::InsertSucceeded;
+    }
+    // insert_status_ remains absl::nullopt if end_stream == false, as we have not completed the
+    // insertion yet.
+  } else {
+    insert_status_ = InsertStatus::NoInsertResponseNotCacheable;
+  }
+  filter_state_ = FilterState::NotServingFromCache;
   return Http::FilterHeadersStatus::Continue;
 }
 
+Http::FilterDataStatus CacheFilter::encodeData(Buffer::Instance& data, bool end_stream) {
+  if (filter_state_ == FilterState::DecodeServingFromCache) {
+    // This call was invoked during decoding by decoder_callbacks_->encodeData because a fresh
+    // cached response was found and is being added to the encoding stream -- ignore it.
+    return Http::FilterDataStatus::Continue;
+  }
+  if (filter_state_ == FilterState::EncodeServingFromCache) {
+    // Stop the encoding stream until the cached response is fetched & added to the encoding stream.
+    return Http::FilterDataStatus::StopIterationAndBuffer;
+  }
+  if (insert_queue_ != nullptr) {
+    ENVOY_STREAM_LOG(debug, "CacheFilter::encodeData inserting body", *encoder_callbacks_);
+    insert_queue_->insertBody(data, end_stream);
+    if (end_stream) {
+      // We don't actually know if the insert succeeded, but as far as the
+      // filter is concerned it has been fully handed off to the cache
+      // implementation.
+      insert_status_ = InsertStatus::InsertSucceeded;
+    }
+  }
+  return Http::FilterDataStatus::Continue;
+}
+
+Http::FilterTrailersStatus CacheFilter::encodeTrailers(Http::ResponseTrailerMap& trailers) {
+  if (filter_state_ == FilterState::DecodeServingFromCache) {
+    // This call was invoked during decoding by decoder_callbacks_->encodeTrailers because a fresh
+    // cached response was found and is being added to the encoding stream -- ignore it.
+    return Http::FilterTrailersStatus::Continue;
+  }
+  if (filter_state_ == FilterState::EncodeServingFromCache) {
+    // Stop the encoding stream until the cached response is fetched & added to the encoding stream.
+    return Http::FilterTrailersStatus::StopIteration;
+  }
+  if (insert_queue_ != nullptr) {
+    ENVOY_STREAM_LOG(debug, "CacheFilter::encodeTrailers inserting trailers", *encoder_callbacks_);
+    insert_queue_->insertTrailers(trailers);
+  }
+  insert_status_ = InsertStatus::InsertSucceeded;
+
+  return Http::FilterTrailersStatus::Continue;
+}
+
 /*static*/ LookupStatus
 CacheFilter::resolveLookupStatus(absl::optional<CacheEntryStatus> cache_entry_status,
                                  FilterState filter_state) {
@@ -193,7 +246,7 @@ CacheFilter::resolveLookupStatus(absl::optional<CacheEntryStatus> cache_entry_st
       switch (filter_state) {
       case FilterState::ValidatingCachedResponse:
         return LookupStatus::RequestIncomplete;
-      case FilterState::ServingFromCache:
+      case FilterState::EncodeServingFromCache:
         ABSL_FALLTHROUGH_INTENDED;
       case FilterState::ResponseServedFromCache:
         // Functionally a cache hit, this is differentiated for metrics reporting.
@@ -202,6 +255,8 @@ CacheFilter::resolveLookupStatus(absl::optional<CacheEntryStatus> cache_entry_st
         return LookupStatus::StaleHitWithFailedValidation;
       case FilterState::Initial:
         ABSL_FALLTHROUGH_INTENDED;
+      case FilterState::DecodeServingFromCache:
+        ABSL_FALLTHROUGH_INTENDED;
       case FilterState::Destroyed:
         IS_ENVOY_BUG(absl::StrCat("Unexpected filter state in requestCacheStatus: cache lookup "
                                   "response required validation, but filter state is ",
@@ -232,7 +287,9 @@ CacheFilter::resolveLookupStatus(absl::optional<CacheEntryStatus> cache_entry_st
   // GCOV_EXCL_START
   case FilterState::ValidatingCachedResponse:
     ABSL_FALLTHROUGH_INTENDED;
-  case FilterState::ServingFromCache:
+  case FilterState::DecodeServingFromCache:
+    ABSL_FALLTHROUGH_INTENDED;
+  case FilterState::EncodeServingFromCache:
     ABSL_FALLTHROUGH_INTENDED;
   case FilterState::ResponseServedFromCache:
     ABSL_FALLTHROUGH_INTENDED;
@@ -308,8 +365,7 @@ void CacheFilter::onHeaders(LookupResult&& result, Http::RequestHeaderMap& reque
 
   // TODO(yosrym93): Handle request only-if-cached directive
   lookup_result_ = std::make_unique<LookupResult>(std::move(result));
-  cache_entry_status_ = lookup_result_->cache_entry_status_;
-  switch (cache_entry_status_.value()) {
+  switch (lookup_result_->cache_entry_status_) {
   case CacheEntryStatus::FoundNotModified:
     PANIC("unsupported code");
   case CacheEntryStatus::RequiresValidation:
@@ -327,7 +383,7 @@ void CacheFilter::onHeaders(LookupResult&& result, Http::RequestHeaderMap& reque
     handleCacheHit(/* end_stream_after_headers = */ end_stream);
     return;
   case CacheEntryStatus::Unusable:
-    sendUpstreamRequest(request_headers);
+    decoder_callbacks_->continueDecoding();
     return;
   case CacheEntryStatus::LookupError:
     filter_state_ = FilterState::NotServingFromCache;
@@ -336,9 +392,9 @@ void CacheFilter::onHeaders(LookupResult&& result, Http::RequestHeaderMap& reque
     return;
   }
   ENVOY_LOG(error, "Unhandled CacheEntryStatus in CacheFilter::onHeaders: {}",
-            cacheEntryStatusString(cache_entry_status_.value()));
+            cacheEntryStatusString(lookup_result_->cache_entry_status_));
   // Treat unhandled status as a cache miss.
-  sendUpstreamRequest(request_headers);
+  decoder_callbacks_->continueDecoding();
 }
 
 // TODO(toddmgreer): Handle downstream backpressure.
@@ -366,11 +422,14 @@ void CacheFilter::onBody(Buffer::InstancePtr&& body, bool end_stream) {
     remaining_ranges_.erase(remaining_ranges_.begin());
   } else {
     ASSERT(false, "Received oversized body from cache.");
-    decoder_callbacks_->resetStream();
+    filter_state_ == FilterState::DecodeServingFromCache ? decoder_callbacks_->resetStream()
+                                                         : encoder_callbacks_->resetStream();
     return;
   }
 
-  decoder_callbacks_->encodeData(*body, end_stream);
+  filter_state_ == FilterState::DecodeServingFromCache
+      ? decoder_callbacks_->encodeData(*body, end_stream)
+      : encoder_callbacks_->addEncodedData(*body, true);
 
   if (end_stream) {
     finalizeEncodingCachedResponse();
@@ -395,16 +454,25 @@ void CacheFilter::onTrailers(Http::ResponseTrailerMapPtr&& trailers) {
     // The filter is being destroyed, any callbacks should be ignored.
     return;
   }
-  decoder_callbacks_->encodeTrailers(std::move(trailers));
-  // Filter can potentially be destroyed during encodeTrailers.
-  if (filter_state_ == FilterState::Destroyed) {
-    return;
+  if (filter_state_ == FilterState::DecodeServingFromCache) {
+    decoder_callbacks_->encodeTrailers(std::move(trailers));
+    // Filter can potentially be destroyed during encodeTrailers.
+    if (filter_state_ == FilterState::Destroyed) {
+      return;
+    }
+  } else {
+    Http::ResponseTrailerMap& response_trailers = encoder_callbacks_->addEncodedTrailers();
+    // Filter can potentially be destroyed during addEncodedTrailers.
+    if (filter_state_ == FilterState::Destroyed) {
+      return;
+    }
+    response_trailers = std::move(*trailers);
   }
   finalizeEncodingCachedResponse();
 }
 
 void CacheFilter::handleCacheHit(bool end_stream_after_headers) {
-  filter_state_ = FilterState::ServingFromCache;
+  filter_state_ = FilterState::DecodeServingFromCache;
   insert_status_ = InsertStatus::NoInsertCacheHit;
   encodeCachedResponse(end_stream_after_headers);
 }
@@ -416,7 +484,7 @@ void CacheFilter::handleCacheHitWithRangeRequest() {
     return;
   }
   if (!lookup_result_->range_details_->satisfiable_) {
-    filter_state_ = FilterState::ServingFromCache;
+    filter_state_ = FilterState::DecodeServingFromCache;
     insert_status_ = InsertStatus::NoInsertCacheHit;
     lookup_result_->headers_->setStatus(
         static_cast<uint64_t>(Envoy::Http::Code::RangeNotSatisfiable));
@@ -435,6 +503,7 @@ void CacheFilter::handleCacheHitWithRangeRequest() {
     // is 0.
     lookup_result_->setContentLength(0);
     encodeCachedResponse(/* end_stream_after_headers = */ true);
+    decoder_callbacks_->continueDecoding();
     return;
   }
 
@@ -451,7 +520,7 @@ void CacheFilter::handleCacheHitWithRangeRequest() {
     return;
   }
 
-  filter_state_ = FilterState::ServingFromCache;
+  filter_state_ = FilterState::DecodeServingFromCache;
   insert_status_ = InsertStatus::NoInsertCacheHit;
 
   lookup_result_->headers_->setStatus(static_cast<uint64_t>(Envoy::Http::Code::PartialContent));
@@ -466,12 +535,84 @@ void CacheFilter::handleCacheHitWithRangeRequest() {
   lookup_result_->setContentLength(ranges[0].length());
   remaining_ranges_ = std::move(ranges);
   encodeCachedResponse(/* end_stream_after_headers = */ false);
+  decoder_callbacks_->continueDecoding();
 }
 
 void CacheFilter::handleCacheHitWithValidation(Envoy::Http::RequestHeaderMap& request_headers) {
   filter_state_ = FilterState::ValidatingCachedResponse;
   injectValidationHeaders(request_headers);
-  sendUpstreamRequest(request_headers);
+  decoder_callbacks_->continueDecoding();
+}
+
+void CacheFilter::processSuccessfulValidation(Http::ResponseHeaderMap& response_headers) {
+  ASSERT(lookup_result_, "CacheFilter trying to validate a non-existent lookup result");
+  ASSERT(
+      filter_state_ == FilterState::ValidatingCachedResponse,
+      "processSuccessfulValidation must only be called when a cached response is being validated");
+  ASSERT(isResponseNotModified(response_headers),
+         "processSuccessfulValidation must only be called with 304 responses");
+
+  // Check whether the cached entry should be updated before modifying the 304 response.
+  const bool should_update_cached_entry = shouldUpdateCachedEntry(response_headers);
+
+  filter_state_ = FilterState::EncodeServingFromCache;
+
+  // Replace the 304 response status code with the cached status code.
+  response_headers.setStatus(lookup_result_->headers_->getStatusValue());
+
+  // Remove content length header if the 304 had one; if the cache entry had a
+  // content length header it will be added by the header adding block below.
+  response_headers.removeContentLength();
+
+  // A response that has been validated should not contain an Age header as it is equivalent to a
+  // freshly served response from the origin, unless the 304 response has an Age header, which
+  // means it was served by an upstream cache.
+  // Remove any existing Age header in the cached response.
+  lookup_result_->headers_->removeInline(CacheCustomHeaders::age());
+
+  // Add any missing headers from the cached response to the 304 response.
+  lookup_result_->headers_->iterate([&response_headers](const Http::HeaderEntry& cached_header) {
+    // TODO(yosrym93): Try to avoid copying the header key twice.
+    Http::LowerCaseString key(cached_header.key().getStringView());
+    absl::string_view value = cached_header.value().getStringView();
+    if (response_headers.get(key).empty()) {
+      response_headers.setCopy(key, value);
+    }
+    return Http::HeaderMap::Iterate::Continue;
+  });
+
+  if (should_update_cached_entry) {
+    // TODO(yosrym93): else the cached entry should be deleted.
+    // Update metadata associated with the cached response. Right now this is only response_time;
+    const ResponseMetadata metadata = {config_->timeSource().systemTime()};
+    cache_->updateHeaders(*lookup_, response_headers, metadata,
+                          [](bool updated ABSL_ATTRIBUTE_UNUSED) {});
+    insert_status_ = InsertStatus::HeaderUpdate;
+  }
+
+  // A cache entry was successfully validated -> encode cached body and trailers.
+  encodeCachedResponse(/* end_stream_after_headers = */ false);
+}
+
+// TODO(yosrym93): Write a test that exercises this when SimpleHttpCache implements updateHeaders
+bool CacheFilter::shouldUpdateCachedEntry(const Http::ResponseHeaderMap& response_headers) const {
+  ASSERT(isResponseNotModified(response_headers),
+         "shouldUpdateCachedEntry must only be called with 304 responses");
+  ASSERT(lookup_result_, "shouldUpdateCachedEntry precondition unsatisfied: lookup_result_ "
+                         "does not point to a cache lookup result");
+  ASSERT(filter_state_ == FilterState::ValidatingCachedResponse,
+         "shouldUpdateCachedEntry precondition unsatisfied: the "
+         "CacheFilter is not validating a cache lookup result");
+
+  // According to: https://httpwg.org/specs/rfc7234.html#freshening.responses,
+  // and assuming a single cached response per key:
+  // If the 304 response contains a strong validator (etag) that does not match the cached response,
+  // the cached response should not be updated.
+  const Http::HeaderEntry* response_etag = response_headers.getInline(CacheCustomHeaders::etag());
+  const Http::HeaderEntry* cached_etag =
+      lookup_result_->headers_->getInline(CacheCustomHeaders::etag());
+  return !response_etag || (cached_etag && cached_etag->value().getStringView() ==
+                                               response_etag->value().getStringView());
 }
 
 void CacheFilter::injectValidationHeaders(Http::RequestHeaderMap& request_headers) {
@@ -508,22 +649,33 @@ void CacheFilter::encodeCachedResponse(bool end_stream_after_headers) {
                          "does not point to a cache lookup result");
 
   // Set appropriate response flags and codes.
-  decoder_callbacks_->streamInfo().setResponseFlag(
-      StreamInfo::CoreResponseFlag::ResponseFromCacheFilter);
-  decoder_callbacks_->streamInfo().setResponseCodeDetails(
+  Http::StreamFilterCallbacks* callbacks =
+      filter_state_ == FilterState::DecodeServingFromCache
+          ? static_cast<Http::StreamFilterCallbacks*>(decoder_callbacks_)
+          : static_cast<Http::StreamFilterCallbacks*>(encoder_callbacks_);
+
+  callbacks->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::ResponseFromCacheFilter);
+  callbacks->streamInfo().setResponseCodeDetails(
       CacheResponseCodeDetails::get().ResponseFromCacheFilter);
 
-  decoder_callbacks_->encodeHeaders(std::move(lookup_result_->headers_),
-                                    is_head_request_ || end_stream_after_headers,
-                                    CacheResponseCodeDetails::get().ResponseFromCacheFilter);
-  // Filter can potentially be destroyed during encodeHeaders.
-  if (filter_state_ == FilterState::Destroyed) {
-    return;
+  // If the filter is encoding, 304 response headers and cached headers are merged in encodeHeaders.
+  // If the filter is decoding, we need to serve response headers from cache directly.
+  if (filter_state_ == FilterState::DecodeServingFromCache) {
+    decoder_callbacks_->encodeHeaders(std::move(lookup_result_->headers_),
+                                      is_head_request_ || end_stream_after_headers,
+                                      CacheResponseCodeDetails::get().ResponseFromCacheFilter);
+    // Filter can potentially be destroyed during encodeHeaders.
+    if (filter_state_ == FilterState::Destroyed) {
+      return;
+    }
   }
-  if (is_head_request_ || end_stream_after_headers) {
+  if (filter_state_ == FilterState::EncodeServingFromCache && is_head_request_) {
     filter_state_ = FilterState::ResponseServedFromCache;
     return;
   }
+  if (end_stream_after_headers || is_head_request_) {
+    return;
+  }
   if (remaining_ranges_.empty() && lookup_result_->content_length_.value_or(1) > 0) {
     // No range has been added, so we add entire body to the response.
     remaining_ranges_.emplace_back(
@@ -537,6 +689,15 @@ void CacheFilter::encodeCachedResponse(bool end_stream_after_headers) {
 }
 
 void CacheFilter::finalizeEncodingCachedResponse() {
+  if (filter_state_ == FilterState::EncodeServingFromCache) {
+    // encodeHeaders returned StopIteration waiting for finishing encoding the cached response --
+    // continue encoding.
+    encoder_callbacks_->continueEncoding();
+    // Filter can potentially be destroyed during continueEncoding.
+    if (filter_state_ == FilterState::Destroyed) {
+      return;
+    }
+  }
   filter_state_ = FilterState::ResponseServedFromCache;
 }
 
@@ -545,13 +706,17 @@ LookupStatus CacheFilter::lookupStatus() const {
     return LookupStatus::RequestIncomplete;
   }
 
-  return resolveLookupStatus(cache_entry_status_, filter_state_);
+  if (lookup_result_ != nullptr) {
+    return resolveLookupStatus(lookup_result_->cache_entry_status_, filter_state_);
+  } else {
+    return resolveLookupStatus(absl::nullopt, filter_state_);
+  }
 }
 
 InsertStatus CacheFilter::insertStatus() const {
-  return insert_status_.value_or((upstream_request_ == nullptr)
+  return insert_status_.value_or((insert_queue_ == nullptr)
                                      ? InsertStatus::NoInsertRequestIncomplete
-                                     : InsertStatus::FilterAbortedBeforeInsertComplete);
+                                     : InsertStatus::InsertAbortedResponseIncomplete);
 }
 
 } // namespace Cache
diff --git source/extensions/filters/http/cache/cache_filter.h source/extensions/filters/http/cache/cache_filter.h
index 3669bbf824..923a1cf197 100644
--- source/extensions/filters/http/cache/cache_filter.h
+++ source/extensions/filters/http/cache/cache_filter.h
@@ -1,6 +1,8 @@
 #pragma once
 
+#include <functional>
 #include <memory>
+#include <string>
 #include <vector>
 
 #include "envoy/extensions/filters/http/cache/v3/cache.pb.h"
@@ -8,7 +10,7 @@
 #include "source/common/common/logger.h"
 #include "source/extensions/filters/http/cache/cache_filter_logging_info.h"
 #include "source/extensions/filters/http/cache/cache_headers_utils.h"
-#include "source/extensions/filters/http/cache/filter_state.h"
+#include "source/extensions/filters/http/cache/cache_insert_queue.h"
 #include "source/extensions/filters/http/cache/http_cache.h"
 #include "source/extensions/filters/http/common/pass_through_filter.h"
 
@@ -17,7 +19,32 @@ namespace Extensions {
 namespace HttpFilters {
 namespace Cache {
 
-class UpstreamRequest;
+enum class FilterState {
+  Initial,
+
+  // Cache lookup found a cached response that requires validation.
+  ValidatingCachedResponse,
+
+  // Cache lookup found a fresh cached response and it is being added to the encoding stream.
+  DecodeServingFromCache,
+
+  // A cached response was successfully validated and it is being added to the encoding stream
+  EncodeServingFromCache,
+
+  // The cached response was successfully added to the encoding stream (either during decoding or
+  // encoding).
+  ResponseServedFromCache,
+
+  // The filter won't serve a response from the cache, whether because the request wasn't cacheable,
+  // there was no response in cache, the response in cache couldn't be served, or the request was
+  // terminated before the cached response could be written. This may be set during decoding or
+  // encoding.
+  NotServingFromCache,
+
+  // CacheFilter::onDestroy has been called, the filter will be destroyed soon. Any triggered
+  // callbacks should be ignored.
+  Destroyed
+};
 
 class CacheFilterConfig {
 public:
@@ -27,16 +54,12 @@ public:
   // The allow list rules that decide if a header can be varied upon.
   const VaryAllowList& varyAllowList() const { return vary_allow_list_; }
   TimeSource& timeSource() const { return time_source_; }
-  const Http::AsyncClient::StreamOptions& upstreamOptions() const { return upstream_options_; }
-  Upstream::ClusterManager& clusterManager() const { return cluster_manager_; }
   bool ignoreRequestCacheControlHeader() const { return ignore_request_cache_control_header_; }
 
 private:
   const VaryAllowList vary_allow_list_;
   TimeSource& time_source_;
   const bool ignore_request_cache_control_header_;
-  Upstream::ClusterManager& cluster_manager_;
-  Http::AsyncClient::StreamOptions upstream_options_;
 };
 
 /**
@@ -57,31 +80,13 @@ public:
   // Http::StreamEncoderFilter
   Http::FilterHeadersStatus encodeHeaders(Http::ResponseHeaderMap& headers,
                                           bool end_stream) override;
+  Http::FilterDataStatus encodeData(Buffer::Instance& buffer, bool end_stream) override;
+  Http::FilterTrailersStatus encodeTrailers(Http::ResponseTrailerMap& trailers) override;
 
   static LookupStatus resolveLookupStatus(absl::optional<CacheEntryStatus> cache_entry_status,
                                           FilterState filter_state);
 
 private:
-  // For a cache miss that may be cacheable, the upstream request is sent outside of the usual
-  // filter chain so that the request can continue even if the downstream client disconnects.
-  void sendUpstreamRequest(Http::RequestHeaderMap& request_headers);
-
-  // In the event that there is no matching route when attempting to sendUpstreamRequest,
-  // send a 404 locally.
-  void sendNoRouteResponse();
-
-  // In the event that there is no available cluster when attempting to sendUpstreamRequest,
-  // send a 503 locally.
-  void sendNoClusterResponse(absl::string_view cluster_name);
-
-  // Called by UpstreamRequest if it is reset before CacheFilter is destroyed.
-  // CacheFilter must make no more calls to upstream_request_ once this has been called.
-  void onUpstreamRequestReset();
-
-  // Called by UpstreamRequest if it finishes without reset before CacheFilter is destroyed.
-  // CacheFilter must make no more calls to upstream_request_ once this has been called.
-  void onUpstreamRequestComplete();
-
   // Utility functions; make any necessary checks and call the corresponding lookup_ functions
   void getHeaders(Http::RequestHeaderMap& request_headers);
   void getBody();
@@ -89,7 +94,7 @@ private:
 
   // Callbacks for HttpCache to call when headers/body/trailers are ready.
   void onHeaders(LookupResult&& result, Http::RequestHeaderMap& request_headers, bool end_stream);
-  void onBody(Buffer::InstancePtr&& body, bool end_stream);
+  void onBody(Buffer::InstancePtr&& bod, bool end_stream);
   void onTrailers(Http::ResponseTrailerMapPtr&& trailers);
 
   // Set required state in the CacheFilter for handling a cache hit.
@@ -103,6 +108,16 @@ private:
   // validation is required.
   void handleCacheHitWithValidation(Envoy::Http::RequestHeaderMap& request_headers);
 
+  // Precondition: lookup_result_ points to a cache lookup result that requires validation.
+  //               filter_state_ is ValidatingCachedResponse.
+  // Serves a validated cached response after updating it with a 304 response.
+  void processSuccessfulValidation(Http::ResponseHeaderMap& response_headers);
+
+  // Precondition: lookup_result_ points to a cache lookup result that requires validation.
+  //               filter_state_ is ValidatingCachedResponse.
+  // Checks if a cached entry should be updated with a 304 response.
+  bool shouldUpdateCachedEntry(const Http::ResponseHeaderMap& response_headers) const;
+
   // Precondition: lookup_result_ points to a cache lookup result that requires validation.
   // Should only be called during onHeaders as it modifies RequestHeaderMap.
   // Adds required conditional headers for cache validation to the request headers
@@ -113,9 +128,6 @@ private:
   // Adds a cache lookup result to the response encoding stream.
   // Can be called during decoding if a valid cache hit is found,
   // or during encoding if a cache entry was validated successfully.
-  //
-  // When validating, headers should be set to the merged values from the validation
-  // response and the lookup_result_; if unset, the headers from the lookup_result_ are used.
   void encodeCachedResponse(bool end_stream_after_headers);
 
   // Precondition: finished adding a response from cache to the response encoding stream.
@@ -130,18 +142,13 @@ private:
   // being cancelled.
   InsertStatus insertStatus() const;
 
-  // upstream_request_ belongs to the object itself, so that it can be disconnected
-  // from the filter and still complete the cache-write in the event that the
-  // downstream disconnects. The filter and the UpstreamRequest must communicate to
-  // each other their separate destruction-triggers.
-  // When CacheFilter is destroyed first it should call
-  // upstream_request_->disconnectFilter()
-  // and if upstream_request_ is destroyed first, it will call onUpstreamRequestReset.
-  UpstreamRequest* upstream_request_ = nullptr;
+  // insert_queue_ ownership may be passed to the queue itself during
+  // CacheFilter::onDestroy, allowing the insert queue to outlive the filter
+  // while the necessary cache write operations complete.
+  std::unique_ptr<CacheInsertQueue> insert_queue_;
   std::shared_ptr<HttpCache> cache_;
   LookupContextPtr lookup_;
   LookupResultPtr lookup_result_;
-  absl::optional<CacheEntryStatus> cache_entry_status_;
 
   // Tracks what body bytes still need to be read from the cache. This is
   // currently only one Range, but will expand when full range support is added. Initialized by
@@ -162,8 +169,6 @@ private:
   // The status of the insert operation or header update, or decision not to insert or update.
   // If it's too early to determine the final status, this is empty.
   absl::optional<InsertStatus> insert_status_;
-
-  friend class UpstreamRequest;
 };
 
 using CacheFilterSharedPtr = std::shared_ptr<CacheFilter>;
diff --git source/extensions/filters/http/cache/cache_filter_logging_info.cc source/extensions/filters/http/cache/cache_filter_logging_info.cc
index 94a5b94eb2..58f27ff907 100644
--- source/extensions/filters/http/cache/cache_filter_logging_info.cc
+++ source/extensions/filters/http/cache/cache_filter_logging_info.cc
@@ -44,8 +44,8 @@ absl::string_view insertStatusToString(InsertStatus status) {
     return "InsertAbortedByCache";
   case InsertStatus::InsertAbortedCacheCongested:
     return "InsertAbortedCacheCongested";
-  case InsertStatus::FilterAbortedBeforeInsertComplete:
-    return "FilterAbortedBeforeInsertComplete";
+  case InsertStatus::InsertAbortedResponseIncomplete:
+    return "InsertAbortedResponseIncomplete";
   case InsertStatus::HeaderUpdate:
     return "HeaderUpdate";
   case InsertStatus::NoInsertCacheHit:
diff --git source/extensions/filters/http/cache/cache_filter_logging_info.h source/extensions/filters/http/cache/cache_filter_logging_info.h
index 296fcf5d45..187843b2c8 100644
--- source/extensions/filters/http/cache/cache_filter_logging_info.h
+++ source/extensions/filters/http/cache/cache_filter_logging_info.h
@@ -54,9 +54,11 @@ enum class InsertStatus {
   // The CacheFilter started an insert, but aborted it because the cache wasn't
   // ready as a body chunk came in.
   InsertAbortedCacheCongested,
-  // The CacheFilter started an insert, but the filter was reset before the insert
-  // completed. The insert may or may not have gone on to completion independently.
-  FilterAbortedBeforeInsertComplete,
+  // The CacheFilter started an insert, but couldn't finish it because the
+  // stream was closed before the response finished. Until the CacheFilter
+  // supports caching response trailers, this will also be reported if it tries
+  // to cache a response with trailers.
+  InsertAbortedResponseIncomplete,
   // The CacheFilter attempted to update the headers of an existing cache entry.
   // This doesn't indicate  whether or not the update succeeded.
   HeaderUpdate,
diff --git source/extensions/filters/http/cache/cache_insert_queue.cc source/extensions/filters/http/cache/cache_insert_queue.cc
index 3f55188e2b..cd817fdcd9 100644
--- source/extensions/filters/http/cache/cache_insert_queue.cc
+++ source/extensions/filters/http/cache/cache_insert_queue.cc
@@ -69,33 +69,22 @@ private:
 
 CacheInsertQueue::CacheInsertQueue(std::shared_ptr<HttpCache> cache,
                                    Http::StreamEncoderFilterCallbacks& encoder_callbacks,
-                                   InsertContextPtr insert_context, InsertQueueCallbacks& callbacks)
+                                   InsertContextPtr insert_context, AbortInsertCallback abort)
     : dispatcher_(encoder_callbacks.dispatcher()), insert_context_(std::move(insert_context)),
       low_watermark_bytes_(encoder_callbacks.bufferLimit() / 2),
-      high_watermark_bytes_(encoder_callbacks.bufferLimit()), callbacks_(callbacks), cache_(cache) {
-}
+      high_watermark_bytes_(encoder_callbacks.bufferLimit()),
+      encoder_callbacks_(encoder_callbacks), abort_callback_(std::move(abort)), cache_(cache) {}
 
 void CacheInsertQueue::insertHeaders(const Http::ResponseHeaderMap& response_headers,
                                      const ResponseMetadata& metadata, bool end_stream) {
   end_stream_queued_ = end_stream;
   // While zero isn't technically true for the size of headers, headers are
   // typically excluded from the stream buffer limit.
-  fragment_in_flight_ = true;
   insert_context_->insertHeaders(
       response_headers, metadata,
       [this, end_stream](bool cache_success) { onFragmentComplete(cache_success, end_stream, 0); },
       end_stream);
-  // This requirement simplifies the cache implementation; most caches will have to
-  // do asynchronous operations, and so will post anyway. It is an error to call continueDecoding
-  // during decodeHeaders, and calling a callback inline *may* do that, therefore we
-  // require the cache to post. A previous version performed a post here to guarantee
-  // correct behavior, but that meant for async caches it would double-post - it makes
-  // more sense to single-post when it may not be necessary (in the rarer case of a cache
-  // not needing async action) than to double-post in the common async case.
-  // This requirement may become unnecessary after some more iterations result in
-  // continueDecoding no longer being a thing in this filter.
-  ASSERT(fragment_in_flight_,
-         "insertHeaders must post the callback to dispatcher, not just call it");
+  fragment_in_flight_ = true;
 }
 
 void CacheInsertQueue::insertBody(const Buffer::Instance& fragment, bool end_stream) {
@@ -107,21 +96,19 @@ void CacheInsertQueue::insertBody(const Buffer::Instance& fragment, bool end_str
     queue_size_bytes_ += sz;
     fragments_.push_back(std::make_unique<CacheInsertFragmentBody>(fragment, end_stream));
     if (!watermarked_ && queue_size_bytes_ > high_watermark_bytes_) {
-      if (callbacks_.has_value()) {
-        callbacks_->insertQueueOverHighWatermark();
+      if (encoder_callbacks_.has_value()) {
+        encoder_callbacks_.value().get().onEncoderFilterAboveWriteBufferHighWatermark();
       }
       watermarked_ = true;
     }
   } else {
-    fragment_in_flight_ = true;
     insert_context_->insertBody(
         Buffer::OwnedImpl(fragment),
         [this, end_stream](bool cache_success) {
           onFragmentComplete(cache_success, end_stream, 0);
         },
         end_stream);
-    ASSERT(fragment_in_flight_,
-           "insertBody must post the callback to dispatcher, not just call it");
+    fragment_in_flight_ = true;
   }
 }
 
@@ -130,11 +117,9 @@ void CacheInsertQueue::insertTrailers(const Http::ResponseTrailerMap& trailers)
   if (fragment_in_flight_) {
     fragments_.push_back(std::make_unique<CacheInsertFragmentTrailers>(trailers));
   } else {
-    fragment_in_flight_ = true;
     insert_context_->insertTrailers(
         trailers, [this](bool cache_success) { onFragmentComplete(cache_success, true, 0); });
-    ASSERT(fragment_in_flight_,
-           "insertTrailers must post the callback to dispatcher, not just call it");
+    fragment_in_flight_ = true;
   }
 }
 
@@ -150,8 +135,8 @@ void CacheInsertQueue::onFragmentComplete(bool cache_success, bool end_stream, s
   ASSERT(queue_size_bytes_ >= sz, "queue can't be emptied by more than its size");
   queue_size_bytes_ -= sz;
   if (watermarked_ && queue_size_bytes_ <= low_watermark_bytes_) {
-    if (callbacks_.has_value()) {
-      callbacks_->insertQueueUnderLowWatermark();
+    if (encoder_callbacks_.has_value()) {
+      encoder_callbacks_.value().get().onEncoderFilterBelowWriteBufferLowWatermark();
     }
     watermarked_ = false;
   }
@@ -159,28 +144,17 @@ void CacheInsertQueue::onFragmentComplete(bool cache_success, bool end_stream, s
     // canceled by cache; unwatermark if necessary, inform the filter if
     // it's still around, and delete the queue.
     if (watermarked_) {
-      if (callbacks_.has_value()) {
-        callbacks_->insertQueueUnderLowWatermark();
+      if (encoder_callbacks_.has_value()) {
+        encoder_callbacks_.value().get().onEncoderFilterBelowWriteBufferLowWatermark();
       }
       watermarked_ = false;
     }
     fragments_.clear();
     // Clearing self-ownership might provoke the destructor, so take a copy of the
     // abort callback to avoid reading from 'this' after it may be deleted.
-    //
-    // This complexity is necessary because if the queue *is not* currently
-    // self-owned, it will be deleted during insertQueueAborted, so
-    // clearing self_ownership_ second would be a write-after-destroy error.
-    // If it *is* currently self-owned, then we must still call the callback if
-    // any, but clearing self_ownership_ *first* would mean we got destroyed
-    // so we would no longer have access to the callback.
-    // Since destroying first *or* second can be an error, rearrange things
-    // so that destroying first *is not* an error. :)
-    auto callbacks = std::move(callbacks_);
+    auto abort_callback = std::move(abort_callback_);
     self_ownership_.reset();
-    if (callbacks.has_value()) {
-      callbacks->insertQueueAborted();
-    }
+    std::move(abort_callback)();
     return;
   }
   if (end_stream) {
@@ -204,13 +178,12 @@ void CacheInsertQueue::setSelfOwned(std::unique_ptr<CacheInsertQueue> self) {
   // If we sent a high watermark event, this is our last chance to unset it on the
   // stream, so we'd better do so.
   if (watermarked_) {
-    if (callbacks_.has_value()) {
-      callbacks_->insertQueueUnderLowWatermark();
-    }
+    encoder_callbacks_->onEncoderFilterBelowWriteBufferLowWatermark();
     watermarked_ = false;
   }
   // Disable all the callbacks, they're going to have nowhere to go.
-  callbacks_.reset();
+  abort_callback_ = []() {};
+  encoder_callbacks_.reset();
   if (fragments_.empty() && !fragment_in_flight_) {
     // If the queue is already empty we can just let it be destroyed immediately.
     return;
diff --git source/extensions/filters/http/cache/cache_insert_queue.h source/extensions/filters/http/cache/cache_insert_queue.h
index b5b8cf5daf..e91b5294cb 100644
--- source/extensions/filters/http/cache/cache_insert_queue.h
+++ source/extensions/filters/http/cache/cache_insert_queue.h
@@ -10,13 +10,9 @@ namespace Extensions {
 namespace HttpFilters {
 namespace Cache {
 
-class InsertQueueCallbacks {
-public:
-  virtual void insertQueueOverHighWatermark() PURE;
-  virtual void insertQueueUnderLowWatermark() PURE;
-  virtual void insertQueueAborted() PURE;
-  virtual ~InsertQueueCallbacks() = default;
-};
+using OverHighWatermarkCallback = std::function<void()>;
+using UnderLowWatermarkCallback = std::function<void()>;
+using AbortInsertCallback = absl::AnyInvocable<void()>;
 class CacheInsertFragment;
 
 // This queue acts as an intermediary between CacheFilter and the cache
@@ -40,7 +36,7 @@ class CacheInsertQueue {
 public:
   CacheInsertQueue(std::shared_ptr<HttpCache> cache,
                    Http::StreamEncoderFilterCallbacks& encoder_callbacks,
-                   InsertContextPtr insert_context, InsertQueueCallbacks& callbacks);
+                   InsertContextPtr insert_context, AbortInsertCallback abort);
   void insertHeaders(const Http::ResponseHeaderMap& response_headers,
                      const ResponseMetadata& metadata, bool end_stream);
   void insertBody(const Buffer::Instance& fragment, bool end_stream);
@@ -54,7 +50,8 @@ private:
   Event::Dispatcher& dispatcher_;
   const InsertContextPtr insert_context_;
   const size_t low_watermark_bytes_, high_watermark_bytes_;
-  OptRef<InsertQueueCallbacks> callbacks_;
+  OptRef<Http::StreamEncoderFilterCallbacks> encoder_callbacks_;
+  AbortInsertCallback abort_callback_;
   std::deque<std::unique_ptr<CacheInsertFragment>> fragments_;
   // Size of the data currently in the queue (including any fragment in flight).
   size_t queue_size_bytes_ = 0;
diff --git source/extensions/filters/http/cache/filter_state.h source/extensions/filters/http/cache/filter_state.h
deleted file mode 100644
index a161aecde5..0000000000
--- source/extensions/filters/http/cache/filter_state.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#pragma once
-
-namespace Envoy {
-namespace Extensions {
-namespace HttpFilters {
-namespace Cache {
-
-enum class FilterState {
-  Initial,
-
-  // Cache lookup found a cached response that requires validation.
-  ValidatingCachedResponse,
-
-  // Cache lookup found a fresh or validated cached response and it is being added to the encoding
-  // stream.
-  ServingFromCache,
-
-  // The cached response was successfully added to the encoding stream (either during decoding or
-  // encoding).
-  ResponseServedFromCache,
-
-  // The filter won't serve a response from the cache, whether because the request wasn't cacheable,
-  // there was no response in cache, the response in cache couldn't be served, or the request was
-  // terminated before the cached response could be written. This may be set during decoding or
-  // encoding.
-  NotServingFromCache,
-
-  // CacheFilter::onDestroy has been called, the filter will be destroyed soon. Any triggered
-  // callbacks should be ignored.
-  Destroyed
-};
-
-} // namespace Cache
-} // namespace HttpFilters
-} // namespace Extensions
-} // namespace Envoy
diff --git source/extensions/filters/http/cache/http_cache.h source/extensions/filters/http/cache/http_cache.h
index 8ae1d5d869..02cc9c80b6 100644
--- source/extensions/filters/http/cache/http_cache.h
+++ source/extensions/filters/http/cache/http_cache.h
@@ -277,13 +277,13 @@ public:
   // read access to a cache entry before its write is complete. In this case the
   // content-length value may be unset.
   virtual LookupContextPtr makeLookupContext(LookupRequest&& request,
-                                             Http::StreamFilterCallbacks& callbacks) PURE;
+                                             Http::StreamDecoderFilterCallbacks& callbacks) PURE;
 
   // Returns an InsertContextPtr to manage the state of a cache insertion.
   // Responses with a chunked transfer-encoding must be dechunked before
   // insertion.
   virtual InsertContextPtr makeInsertContext(LookupContextPtr&& lookup_context,
-                                             Http::StreamFilterCallbacks& callbacks) PURE;
+                                             Http::StreamEncoderFilterCallbacks& callbacks) PURE;
 
   // Precondition: lookup_context represents a prior cache lookup that required
   // validation.
diff --git source/extensions/filters/http/cache/upstream_request.cc source/extensions/filters/http/cache/upstream_request.cc
deleted file mode 100644
index 550b81c59a..0000000000
--- source/extensions/filters/http/cache/upstream_request.cc
+++ /dev/null
@@ -1,272 +0,0 @@
-#include "source/extensions/filters/http/cache/upstream_request.h"
-
-#include "source/common/common/enum_to_int.h"
-#include "source/common/http/utility.h"
-#include "source/extensions/filters/http/cache/cache_custom_headers.h"
-#include "source/extensions/filters/http/cache/cache_filter.h"
-#include "source/extensions/filters/http/cache/cacheability_utils.h"
-
-namespace Envoy {
-namespace Extensions {
-namespace HttpFilters {
-namespace Cache {
-
-namespace {
-inline bool isResponseNotModified(const Http::ResponseHeaderMap& response_headers) {
-  return Http::Utility::getResponseStatus(response_headers) == enumToInt(Http::Code::NotModified);
-}
-} // namespace
-
-void UpstreamRequest::setFilterState(FilterState fs) {
-  filter_state_ = fs;
-  if (filter_ != nullptr && filter_->filter_state_ != FilterState::Destroyed) {
-    filter_->filter_state_ = fs;
-  }
-}
-
-void UpstreamRequest::setInsertStatus(InsertStatus is) {
-  if (filter_ != nullptr && filter_->filter_state_ != FilterState::Destroyed) {
-    filter_->insert_status_ = is;
-  }
-}
-
-void UpstreamRequest::processSuccessfulValidation(Http::ResponseHeaderMapPtr response_headers) {
-  ASSERT(lookup_result_, "CacheFilter trying to validate a non-existent lookup result");
-  ASSERT(
-      filter_state_ == FilterState::ValidatingCachedResponse,
-      "processSuccessfulValidation must only be called when a cached response is being validated");
-  ASSERT(isResponseNotModified(*response_headers),
-         "processSuccessfulValidation must only be called with 304 responses");
-
-  // Check whether the cached entry should be updated before modifying the 304 response.
-  const bool should_update_cached_entry = shouldUpdateCachedEntry(*response_headers);
-
-  setFilterState(FilterState::ServingFromCache);
-
-  // Replace the 304 response status code with the cached status code.
-  response_headers->setStatus(lookup_result_->headers_->getStatusValue());
-
-  // Remove content length header if the 304 had one; if the cache entry had a
-  // content length header it will be added by the header adding block below.
-  response_headers->removeContentLength();
-
-  // A response that has been validated should not contain an Age header as it is equivalent to a
-  // freshly served response from the origin, unless the 304 response has an Age header, which
-  // means it was served by an upstream cache.
-  // Remove any existing Age header in the cached response.
-  lookup_result_->headers_->removeInline(CacheCustomHeaders::age());
-
-  // Add any missing headers from the cached response to the 304 response.
-  lookup_result_->headers_->iterate([&response_headers](const Http::HeaderEntry& cached_header) {
-    // TODO(yosrym93): Try to avoid copying the header key twice.
-    Http::LowerCaseString key(cached_header.key().getStringView());
-    absl::string_view value = cached_header.value().getStringView();
-    if (response_headers->get(key).empty()) {
-      response_headers->setCopy(key, value);
-    }
-    return Http::HeaderMap::Iterate::Continue;
-  });
-
-  if (should_update_cached_entry) {
-    // TODO(yosrym93): else the cached entry should be deleted.
-    // Update metadata associated with the cached response. Right now this is only response_time;
-    const ResponseMetadata metadata = {config_->timeSource().systemTime()};
-    cache_->updateHeaders(*lookup_, *response_headers, metadata,
-                          [](bool updated ABSL_ATTRIBUTE_UNUSED) {});
-    setInsertStatus(InsertStatus::HeaderUpdate);
-  }
-
-  // A cache entry was successfully validated, so abort the upstream request, send
-  // encode the merged-modified headers, and encode cached body and trailers.
-  if (filter_ != nullptr) {
-    lookup_result_->headers_ = std::move(response_headers);
-    filter_->lookup_result_ = std::move(lookup_result_);
-    filter_->lookup_ = std::move(lookup_);
-    filter_->upstream_request_ = nullptr;
-    lookup_result_ = nullptr;
-    filter_->encodeCachedResponse(/* end_stream_after_headers = */ false);
-    filter_ = nullptr;
-    abort();
-  }
-}
-
-// TODO(yosrym93): Write a test that exercises this when SimpleHttpCache implements updateHeaders
-bool UpstreamRequest::shouldUpdateCachedEntry(
-    const Http::ResponseHeaderMap& response_headers) const {
-  ASSERT(isResponseNotModified(response_headers),
-         "shouldUpdateCachedEntry must only be called with 304 responses");
-  ASSERT(lookup_result_, "shouldUpdateCachedEntry precondition unsatisfied: lookup_result_ "
-                         "does not point to a cache lookup result");
-  ASSERT(filter_state_ == FilterState::ValidatingCachedResponse,
-         "shouldUpdateCachedEntry precondition unsatisfied: the "
-         "CacheFilter is not validating a cache lookup result");
-
-  // According to: https://httpwg.org/specs/rfc7234.html#freshening.responses,
-  // and assuming a single cached response per key:
-  // If the 304 response contains a strong validator (etag) that does not match the cached response,
-  // the cached response should not be updated.
-  const Http::HeaderEntry* response_etag = response_headers.getInline(CacheCustomHeaders::etag());
-  const Http::HeaderEntry* cached_etag =
-      lookup_result_->headers_->getInline(CacheCustomHeaders::etag());
-  return !response_etag || (cached_etag && cached_etag->value().getStringView() ==
-                                               response_etag->value().getStringView());
-}
-
-UpstreamRequest* UpstreamRequest::create(CacheFilter* filter, LookupContextPtr lookup,
-                                         LookupResultPtr lookup_result,
-                                         std::shared_ptr<HttpCache> cache,
-                                         Http::AsyncClient& async_client,
-                                         const Http::AsyncClient::StreamOptions& options) {
-  return new UpstreamRequest(filter, std::move(lookup), std::move(lookup_result), std::move(cache),
-                             async_client, options);
-}
-
-UpstreamRequest::UpstreamRequest(CacheFilter* filter, LookupContextPtr lookup,
-                                 LookupResultPtr lookup_result, std::shared_ptr<HttpCache> cache,
-                                 Http::AsyncClient& async_client,
-                                 const Http::AsyncClient::StreamOptions& options)
-    : filter_(filter), lookup_(std::move(lookup)), lookup_result_(std::move(lookup_result)),
-      is_head_request_(filter->is_head_request_),
-      request_allows_inserts_(filter->request_allows_inserts_), config_(filter->config_),
-      filter_state_(filter->filter_state_), cache_(std::move(cache)),
-      stream_(async_client.start(*this, options)) {
-  ASSERT(stream_ != nullptr);
-}
-
-void UpstreamRequest::insertQueueOverHighWatermark() {
-  // TODO(ravenblack): currently AsyncRequest::Stream does not support pausing.
-}
-
-void UpstreamRequest::insertQueueUnderLowWatermark() {
-  // TODO(ravenblack): currently AsyncRequest::Stream does not support pausing.
-}
-
-void UpstreamRequest::insertQueueAborted() {
-  insert_queue_ = nullptr;
-  ENVOY_LOG(debug, "cache aborted insert operation");
-  setInsertStatus(InsertStatus::InsertAbortedByCache);
-  if (filter_ == nullptr) {
-    abort();
-  }
-}
-
-void UpstreamRequest::sendHeaders(Http::RequestHeaderMap& request_headers) {
-  // If this request had a body or trailers, CacheFilter::decodeHeaders
-  // would have bypassed cache lookup and insertion, so this class wouldn't
-  // be instantiated. So end_stream will always be true.
-  stream_->sendHeaders(request_headers, true);
-}
-
-void UpstreamRequest::abort() {
-  stream_->reset(); // Calls onReset, resulting in deletion.
-}
-
-UpstreamRequest::~UpstreamRequest() {
-  if (filter_ != nullptr) {
-    filter_->onUpstreamRequestReset();
-  }
-  if (lookup_) {
-    lookup_->onDestroy();
-    lookup_ = nullptr;
-  }
-  if (insert_queue_) {
-    // The insert queue may still have actions in flight, so it needs to be allowed
-    // to drain itself before destruction.
-    insert_queue_->setSelfOwned(std::move(insert_queue_));
-  }
-}
-
-void UpstreamRequest::onReset() { delete this; }
-void UpstreamRequest::onComplete() {
-  if (filter_) {
-    ENVOY_STREAM_LOG(debug, "UpstreamRequest complete", *filter_->decoder_callbacks_);
-    filter_->onUpstreamRequestComplete();
-    filter_ = nullptr;
-  } else {
-    ENVOY_LOG(debug, "UpstreamRequest complete after stream finished");
-  }
-  delete this;
-}
-void UpstreamRequest::disconnectFilter() {
-  filter_ = nullptr;
-  if (insert_queue_ == nullptr) {
-    abort();
-  }
-}
-
-void UpstreamRequest::onHeaders(Http::ResponseHeaderMapPtr&& headers, bool end_stream) {
-  if (filter_state_ == FilterState::ValidatingCachedResponse && isResponseNotModified(*headers)) {
-    return processSuccessfulValidation(std::move(headers));
-  }
-  // Either a cache miss or a cache entry that is no longer valid.
-  // Check if the new response can be cached.
-  if (request_allows_inserts_ && !is_head_request_ &&
-      CacheabilityUtils::isCacheableResponse(*headers, config_->varyAllowList())) {
-    if (filter_) {
-      ENVOY_STREAM_LOG(debug, "UpstreamRequest::onHeaders inserting headers",
-                       *filter_->decoder_callbacks_);
-    }
-    auto insert_context =
-        cache_->makeInsertContext(std::move(lookup_), *filter_->encoder_callbacks_);
-    lookup_ = nullptr;
-    if (insert_context != nullptr) {
-      // The callbacks passed to CacheInsertQueue are all called through the dispatcher,
-      // so they're thread-safe. During CacheFilter::onDestroy the queue is given ownership
-      // of itself and all the callbacks are cancelled, so they are also filter-destruction-safe.
-      insert_queue_ = std::make_unique<CacheInsertQueue>(cache_, *filter_->encoder_callbacks_,
-                                                         std::move(insert_context), *this);
-      // Add metadata associated with the cached response. Right now this is only response_time;
-      const ResponseMetadata metadata = {config_->timeSource().systemTime()};
-      insert_queue_->insertHeaders(*headers, metadata, end_stream);
-      // insert_status_ remains absl::nullopt if end_stream == false, as we have not completed the
-      // insertion yet.
-      if (end_stream) {
-        setInsertStatus(InsertStatus::InsertSucceeded);
-      }
-    }
-  } else {
-    setInsertStatus(InsertStatus::NoInsertResponseNotCacheable);
-  }
-  setFilterState(FilterState::NotServingFromCache);
-  if (filter_) {
-    filter_->decoder_callbacks_->encodeHeaders(std::move(headers), is_head_request_ || end_stream,
-                                               StreamInfo::ResponseCodeDetails::get().ViaUpstream);
-  }
-}
-
-void UpstreamRequest::onData(Buffer::Instance& body, bool end_stream) {
-  if (insert_queue_ != nullptr) {
-    insert_queue_->insertBody(body, end_stream);
-  }
-  if (filter_) {
-    ENVOY_STREAM_LOG(debug, "UpstreamRequest::onData inserted body", *filter_->decoder_callbacks_);
-    filter_->decoder_callbacks_->encodeData(body, end_stream);
-    if (end_stream) {
-      // We don't actually know at this point if the insert succeeded, but as far as the
-      // filter is concerned it has been fully handed off to the cache
-      // implementation.
-      setInsertStatus(InsertStatus::InsertSucceeded);
-    }
-  } else {
-    ENVOY_LOG(debug, "UpstreamRequest::onData inserted body");
-  }
-}
-
-void UpstreamRequest::onTrailers(Http::ResponseTrailerMapPtr&& trailers) {
-  if (insert_queue_ != nullptr) {
-    insert_queue_->insertTrailers(*trailers);
-  }
-  if (filter_ != nullptr) {
-    ENVOY_STREAM_LOG(debug, "UpstreamRequest::onTrailers inserting trailers",
-                     *filter_->decoder_callbacks_);
-    filter_->decoder_callbacks_->encodeTrailers(std::move(trailers));
-    setInsertStatus(InsertStatus::InsertSucceeded);
-  } else {
-    ENVOY_LOG(debug, "UpstreamRequest::onTrailers inserting trailers");
-  }
-}
-
-} // namespace Cache
-} // namespace HttpFilters
-} // namespace Extensions
-} // namespace Envoy
diff --git source/extensions/filters/http/cache/upstream_request.h source/extensions/filters/http/cache/upstream_request.h
deleted file mode 100644
index 6aa6259ca2..0000000000
--- source/extensions/filters/http/cache/upstream_request.h
+++ /dev/null
@@ -1,84 +0,0 @@
-#pragma once
-
-#include "source/common/common/logger.h"
-#include "source/extensions/filters/http/cache/cache_filter_logging_info.h"
-#include "source/extensions/filters/http/cache/cache_insert_queue.h"
-
-namespace Envoy {
-namespace Extensions {
-namespace HttpFilters {
-namespace Cache {
-
-class CacheFilter;
-class CacheFilterConfig;
-enum class FilterState;
-
-class UpstreamRequest : public Logger::Loggable<Logger::Id::cache_filter>,
-                        public Http::AsyncClient::StreamCallbacks,
-                        public InsertQueueCallbacks {
-public:
-  void sendHeaders(Http::RequestHeaderMap& request_headers);
-  // Called by filter_ when filter_ is destroyed first.
-  // UpstreamRequest will make no more calls to filter_ once disconnectFilter
-  // has been called.
-  void disconnectFilter();
-
-  // StreamCallbacks
-  void onHeaders(Http::ResponseHeaderMapPtr&& headers, bool end_stream) override;
-  void onData(Buffer::Instance& data, bool end_stream) override;
-  void onTrailers(Http::ResponseTrailerMapPtr&& trailers) override;
-  void onComplete() override;
-  void onReset() override;
-
-  // InsertQueueCallbacks
-  void insertQueueOverHighWatermark() override;
-  void insertQueueUnderLowWatermark() override;
-  void insertQueueAborted() override;
-
-  static UpstreamRequest* create(CacheFilter* filter, LookupContextPtr lookup,
-                                 LookupResultPtr lookup_result, std::shared_ptr<HttpCache> cache,
-                                 Http::AsyncClient& async_client,
-                                 const Http::AsyncClient::StreamOptions& options);
-  UpstreamRequest(CacheFilter* filter, LookupContextPtr lookup, LookupResultPtr lookup_result,
-                  std::shared_ptr<HttpCache> cache, Http::AsyncClient& async_client,
-                  const Http::AsyncClient::StreamOptions& options);
-  ~UpstreamRequest() override;
-
-private:
-  // Precondition: lookup_result_ points to a cache lookup result that requires validation.
-  //               filter_state_ is ValidatingCachedResponse.
-  // Serves a validated cached response after updating it with a 304 response.
-  void processSuccessfulValidation(Http::ResponseHeaderMapPtr response_headers);
-
-  // Updates the filter state belonging to the UpstreamRequest, and the one belonging to
-  // the filter if it has not been destroyed.
-  void setFilterState(FilterState fs);
-
-  // Updates the insert status belonging to the filter, if it has not been destroyed.
-  void setInsertStatus(InsertStatus is);
-
-  // If an error occurs while the stream is active, abort will reset the stream, which
-  // in turn provokes the rest of the destruction process.
-  void abort();
-
-  // Precondition: lookup_result_ points to a cache lookup result that requires validation.
-  //               filter_state_ is ValidatingCachedResponse.
-  // Checks if a cached entry should be updated with a 304 response.
-  bool shouldUpdateCachedEntry(const Http::ResponseHeaderMap& response_headers) const;
-
-  CacheFilter* filter_ = nullptr;
-  LookupContextPtr lookup_;
-  LookupResultPtr lookup_result_;
-  bool is_head_request_;
-  bool request_allows_inserts_;
-  std::shared_ptr<const CacheFilterConfig> config_;
-  FilterState filter_state_;
-  std::shared_ptr<HttpCache> cache_;
-  Http::AsyncClient::Stream* stream_ = nullptr;
-  std::unique_ptr<CacheInsertQueue> insert_queue_;
-};
-
-} // namespace Cache
-} // namespace HttpFilters
-} // namespace Extensions
-} // namespace Envoy
diff --git source/extensions/http/cache/file_system_http_cache/file_system_http_cache.cc source/extensions/http/cache/file_system_http_cache/file_system_http_cache.cc
index 7fbd44346f..f847082ad9 100644
--- source/extensions/http/cache/file_system_http_cache/file_system_http_cache.cc
+++ source/extensions/http/cache/file_system_http_cache/file_system_http_cache.cc
@@ -115,8 +115,9 @@ FileSystemHttpCache::makeVaryKey(const Key& base, const VaryAllowList& vary_allo
   return vary_key;
 }
 
-LookupContextPtr FileSystemHttpCache::makeLookupContext(LookupRequest&& lookup,
-                                                        Http::StreamFilterCallbacks& callbacks) {
+LookupContextPtr
+FileSystemHttpCache::makeLookupContext(LookupRequest&& lookup,
+                                       Http::StreamDecoderFilterCallbacks& callbacks) {
   return std::make_unique<FileLookupContext>(callbacks.dispatcher(), *this, std::move(lookup));
 }
 
@@ -351,14 +352,12 @@ std::string FileSystemHttpCache::generateFilename(const Key& key) const {
 }
 
 InsertContextPtr FileSystemHttpCache::makeInsertContext(LookupContextPtr&& lookup_context,
-                                                        Http::StreamFilterCallbacks&) {
+                                                        Http::StreamEncoderFilterCallbacks&) {
   auto file_lookup_context = std::unique_ptr<FileLookupContext>(
       dynamic_cast<FileLookupContext*>(lookup_context.release()));
   ASSERT(file_lookup_context);
   if (file_lookup_context->workInProgress()) {
-    auto ret = std::make_unique<DontInsertContext>(*file_lookup_context->dispatcher());
-    file_lookup_context->onDestroy();
-    return ret;
+    return std::make_unique<DontInsertContext>();
   }
   return std::make_unique<FileInsertContext>(shared_from_this(), std::move(file_lookup_context));
 }
diff --git source/extensions/http/cache/file_system_http_cache/file_system_http_cache.h source/extensions/http/cache/file_system_http_cache/file_system_http_cache.h
index 97cd77a40e..be4c594024 100644
--- source/extensions/http/cache/file_system_http_cache/file_system_http_cache.h
+++ source/extensions/http/cache/file_system_http_cache/file_system_http_cache.h
@@ -47,9 +47,9 @@ public:
 
   // Overrides for HttpCache
   LookupContextPtr makeLookupContext(LookupRequest&& lookup,
-                                     Http::StreamFilterCallbacks& callbacks) override;
+                                     Http::StreamDecoderFilterCallbacks& callbacks) override;
   InsertContextPtr makeInsertContext(LookupContextPtr&& lookup_context,
-                                     Http::StreamFilterCallbacks& callbacks) override;
+                                     Http::StreamEncoderFilterCallbacks& callbacks) override;
   CacheInfo cacheInfo() const override;
   const CacheStats& stats() const;
 
diff --git source/extensions/http/cache/file_system_http_cache/insert_context.cc source/extensions/http/cache/file_system_http_cache/insert_context.cc
index a2fc30b2f6..55503ef6dd 100644
--- source/extensions/http/cache/file_system_http_cache/insert_context.cc
+++ source/extensions/http/cache/file_system_http_cache/insert_context.cc
@@ -193,10 +193,7 @@ void FileInsertContext::insertTrailers(const Http::ResponseTrailerMap& trailers,
   cancel_action_in_flight_ = std::move(queued.value());
 }
 
-void FileInsertContext::onDestroy() {
-  lookup_context_->onDestroy();
-  cancelInsert("InsertContext destroyed prematurely");
-}
+void FileInsertContext::onDestroy() { cancelInsert("InsertContext destroyed prematurely"); }
 
 void FileInsertContext::commit() {
   ASSERT(dispatcher()->isThreadSafe());
diff --git source/extensions/http/cache/file_system_http_cache/insert_context.h source/extensions/http/cache/file_system_http_cache/insert_context.h
index 73433f43d4..45efd79ba7 100644
--- source/extensions/http/cache/file_system_http_cache/insert_context.h
+++ source/extensions/http/cache/file_system_http_cache/insert_context.h
@@ -21,21 +21,17 @@ class FileSystemHttpCache;
 
 class DontInsertContext : public InsertContext {
 public:
-  explicit DontInsertContext(Event::Dispatcher& dispatcher) : dispatcher_(dispatcher) {}
   void insertHeaders(const Http::ResponseHeaderMap&, const ResponseMetadata&,
                      InsertCallback insert_complete, bool) override {
-    dispatcher_.post([cb = std::move(insert_complete)]() mutable { cb(false); });
+    insert_complete(false);
   }
   void insertBody(const Buffer::Instance&, InsertCallback ready_for_next_chunk, bool) override {
-    dispatcher_.post([cb = std::move(ready_for_next_chunk)]() mutable { cb(false); });
+    ready_for_next_chunk(false);
   }
   void insertTrailers(const Http::ResponseTrailerMap&, InsertCallback insert_complete) override {
-    dispatcher_.post([cb = std::move(insert_complete)]() mutable { cb(false); });
+    insert_complete(false);
   }
   void onDestroy() override {};
-
-private:
-  Event::Dispatcher& dispatcher_;
 };
 
 class FileInsertContext : public InsertContext, public Logger::Loggable<Logger::Id::cache_filter> {
diff --git source/extensions/http/cache/simple_http_cache/simple_http_cache.cc source/extensions/http/cache/simple_http_cache/simple_http_cache.cc
index 7075452b3d..3c604e0f1c 100644
--- source/extensions/http/cache/simple_http_cache/simple_http_cache.cc
+++ source/extensions/http/cache/simple_http_cache/simple_http_cache.cc
@@ -168,7 +168,7 @@ private:
 } // namespace
 
 LookupContextPtr SimpleHttpCache::makeLookupContext(LookupRequest&& request,
-                                                    Http::StreamFilterCallbacks& callbacks) {
+                                                    Http::StreamDecoderFilterCallbacks& callbacks) {
   return std::make_unique<SimpleLookupContext>(callbacks.dispatcher(), *this, std::move(request));
 }
 
@@ -311,12 +311,10 @@ bool SimpleHttpCache::varyInsert(const Key& request_key,
 }
 
 InsertContextPtr SimpleHttpCache::makeInsertContext(LookupContextPtr&& lookup_context,
-                                                    Http::StreamFilterCallbacks&) {
+                                                    Http::StreamEncoderFilterCallbacks&) {
   ASSERT(lookup_context != nullptr);
-  auto ret = std::make_unique<SimpleInsertContext>(
-      dynamic_cast<SimpleLookupContext&>(*lookup_context), *this);
-  lookup_context->onDestroy();
-  return ret;
+  return std::make_unique<SimpleInsertContext>(dynamic_cast<SimpleLookupContext&>(*lookup_context),
+                                               *this);
 }
 
 constexpr absl::string_view Name = "envoy.extensions.http.cache.simple";
diff --git source/extensions/http/cache/simple_http_cache/simple_http_cache.h source/extensions/http/cache/simple_http_cache/simple_http_cache.h
index 3acb936ac6..515ccc5f01 100644
--- source/extensions/http/cache/simple_http_cache/simple_http_cache.h
+++ source/extensions/http/cache/simple_http_cache/simple_http_cache.h
@@ -35,9 +35,9 @@ private:
 public:
   // HttpCache
   LookupContextPtr makeLookupContext(LookupRequest&& request,
-                                     Http::StreamFilterCallbacks& callbacks) override;
+                                     Http::StreamDecoderFilterCallbacks& callbacks) override;
   InsertContextPtr makeInsertContext(LookupContextPtr&& lookup_context,
-                                     Http::StreamFilterCallbacks& callbacks) override;
+                                     Http::StreamEncoderFilterCallbacks& callbacks) override;
   void updateHeaders(const LookupContext& lookup_context,
                      const Http::ResponseHeaderMap& response_headers,
                      const ResponseMetadata& metadata, UpdateHeadersCallback on_complete) override;
diff --git test/extensions/filters/http/cache/cache_filter_logging_info_test.cc test/extensions/filters/http/cache/cache_filter_logging_info_test.cc
index 6aa76376fe..79ba6e4210 100644
--- test/extensions/filters/http/cache/cache_filter_logging_info_test.cc
+++ test/extensions/filters/http/cache/cache_filter_logging_info_test.cc
@@ -30,8 +30,8 @@ TEST(Coverage, InsertStatusToString) {
   EXPECT_EQ(insertStatusToString(InsertStatus::InsertAbortedByCache), "InsertAbortedByCache");
   EXPECT_EQ(insertStatusToString(InsertStatus::InsertAbortedCacheCongested),
             "InsertAbortedCacheCongested");
-  EXPECT_EQ(insertStatusToString(InsertStatus::FilterAbortedBeforeInsertComplete),
-            "FilterAbortedBeforeInsertComplete");
+  EXPECT_EQ(insertStatusToString(InsertStatus::InsertAbortedResponseIncomplete),
+            "InsertAbortedResponseIncomplete");
   EXPECT_EQ(insertStatusToString(InsertStatus::HeaderUpdate), "HeaderUpdate");
   EXPECT_EQ(insertStatusToString(InsertStatus::NoInsertCacheHit), "NoInsertCacheHit");
   EXPECT_EQ(insertStatusToString(InsertStatus::NoInsertRequestNotCacheable),
diff --git test/extensions/filters/http/cache/cache_filter_test.cc test/extensions/filters/http/cache/cache_filter_test.cc
index 2ec883992f..2da0b75a62 100644
--- test/extensions/filters/http/cache/cache_filter_test.cc
+++ test/extensions/filters/http/cache/cache_filter_test.cc
@@ -1,5 +1,3 @@
-#include <functional>
-
 #include "envoy/event/dispatcher.h"
 
 #include "source/common/http/headers.h"
@@ -27,7 +25,6 @@ using ::Envoy::StatusHelpers::IsOkAndHolds;
 using ::testing::Gt;
 using ::testing::IsNull;
 using ::testing::NotNull;
-using ::testing::Return;
 
 class CacheFilterTest : public ::testing::Test {
 protected:
@@ -50,31 +47,6 @@ protected:
   }
 
   void SetUp() override {
-    context_.server_factory_context_.cluster_manager_.initializeThreadLocalClusters(
-        {"fake_cluster"});
-    ON_CALL(context_.server_factory_context_.cluster_manager_.thread_local_cluster_.async_client_,
-            start)
-        .WillByDefault([this](Http::AsyncClient::StreamCallbacks& callbacks,
-                              const Http::AsyncClient::StreamOptions&) {
-          int i = mock_upstreams_.size();
-          mock_upstreams_.push_back(std::make_unique<NiceMock<Http::MockAsyncClientStream>>());
-          mock_upstreams_callbacks_.emplace_back(std::ref(callbacks));
-          auto ret = mock_upstreams_.back().get();
-          mock_upstreams_headers_sent_.emplace_back();
-          ON_CALL(*ret, sendHeaders)
-              .WillByDefault([this, i](Http::RequestHeaderMap& headers, bool end_stream) {
-                EXPECT_EQ(mock_upstreams_headers_sent_[i], absl::nullopt)
-                    << "headers should only be sent once";
-                EXPECT_TRUE(end_stream) << "post requests should be bypassing the filter";
-                mock_upstreams_headers_sent_[i] = Http::TestRequestHeaderMapImpl();
-                mock_upstreams_headers_sent_[i]->copyFrom(headers);
-              });
-          ON_CALL(*ret, reset).WillByDefault([this, i]() {
-            mock_upstreams_callbacks_[i].get().onReset();
-          });
-          return ret;
-        });
-
     ON_CALL(encoder_callbacks_, dispatcher()).WillByDefault(::testing::ReturnRef(*dispatcher_));
     ON_CALL(decoder_callbacks_, dispatcher()).WillByDefault(::testing::ReturnRef(*dispatcher_));
     ON_CALL(decoder_callbacks_.stream_info_, filterState())
@@ -109,116 +81,24 @@ protected:
     return info_or.status();
   }
 
-  void pumpDispatcher() { dispatcher_->run(Event::Dispatcher::RunType::Block); }
-
-  void receiveUpstreamComplete(size_t upstream_index) {
-    ASSERT(mock_upstreams_callbacks_.size() > upstream_index);
-    mock_upstreams_callbacks_[upstream_index].get().onComplete();
-  }
-
-  void
-  receiveUpstreamHeaders(size_t upstream_index, Http::ResponseHeaderMap& headers, bool end_stream,
-                         testing::Matcher<Http::ResponseHeaderMap&> expected_response_headers = _) {
-    ASSERT(mock_upstreams_callbacks_.size() > upstream_index);
-
-    EXPECT_CALL(decoder_callbacks_, encodeHeaders_(expected_response_headers, _));
-
-    mock_upstreams_callbacks_[upstream_index].get().onHeaders(
-        std::make_unique<Http::TestResponseHeaderMapImpl>(headers), end_stream);
-    ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
-    if (end_stream) {
-      receiveUpstreamComplete(upstream_index);
-    }
-  }
-
-  // On successful verification, the upstream request gets reset rather than
-  // onComplete.
-  void receiveUpstreamHeadersWithReset(
-      size_t upstream_index, Http::ResponseHeaderMap& headers, bool end_stream,
-      testing::Matcher<Http::ResponseHeaderMap&> expected_response_headers = _) {
-    ASSERT(mock_upstreams_callbacks_.size() > upstream_index);
-    ASSERT(mock_upstreams_.size() > upstream_index);
-    EXPECT_CALL(*mock_upstreams_[upstream_index], reset());
-    EXPECT_CALL(decoder_callbacks_, encodeHeaders_(expected_response_headers, _));
-    mock_upstreams_callbacks_[upstream_index].get().onHeaders(
-        std::make_unique<Http::TestResponseHeaderMapImpl>(headers), end_stream);
-    ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
-    testing::Mock::VerifyAndClearExpectations(mock_upstreams_[1].get());
-  }
-
-  void receiveUpstreamBody(size_t upstream_index, absl::string_view body, bool end_stream) {
-    ASSERT(mock_upstreams_callbacks_.size() > upstream_index);
-    EXPECT_CALL(decoder_callbacks_, encodeData);
-    Buffer::OwnedImpl buf{body};
-    mock_upstreams_callbacks_[upstream_index].get().onData(buf, end_stream);
-    ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
-    if (end_stream) {
-      receiveUpstreamComplete(upstream_index);
-    }
-  }
-
-  void receiveUpstreamBodyAfterFilterDestroyed(size_t upstream_index, absl::string_view body,
-                                               bool end_stream) {
-    // Same as receiveUpstreamBody but without expecting a call to encodeData.
-    ASSERT(mock_upstreams_callbacks_.size() > upstream_index);
-    Buffer::OwnedImpl buf{body};
-    mock_upstreams_callbacks_[upstream_index].get().onData(buf, end_stream);
-    if (end_stream) {
-      receiveUpstreamComplete(upstream_index);
-    }
-  }
-
-  void receiveUpstreamTrailers(size_t upstream_index, Http::ResponseTrailerMap& trailers) {
-    ASSERT(mock_upstreams_callbacks_.size() > upstream_index);
-    EXPECT_CALL(decoder_callbacks_, encodeTrailers_);
-    mock_upstreams_callbacks_[upstream_index].get().onTrailers(
-        std::make_unique<Http::TestResponseTrailerMapImpl>(trailers));
-    ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
-    receiveUpstreamComplete(upstream_index);
-  }
-
-  void receiveUpstreamTrailersAfterFilterDestroyed(size_t upstream_index,
-                                                   Http::ResponseTrailerMap& trailers) {
-    ASSERT(mock_upstreams_callbacks_.size() > upstream_index);
-    mock_upstreams_callbacks_[upstream_index].get().onTrailers(
-        std::make_unique<Http::TestResponseTrailerMapImpl>(trailers));
-    receiveUpstreamComplete(upstream_index);
-  }
-
-  void populateCommonCacheEntry(size_t upstream_index, CacheFilterSharedPtr filter,
-                                absl::string_view body = "",
-                                OptRef<Http::ResponseTrailerMap> trailers = absl::nullopt) {
-    testDecodeRequestMiss(upstream_index, filter);
-
-    receiveUpstreamHeaders(upstream_index, response_headers_,
-                           body.empty() && trailers == absl::nullopt);
-
-    if (!body.empty()) {
-      receiveUpstreamBody(upstream_index, body, trailers == absl::nullopt);
-    }
-    if (trailers) {
-      receiveUpstreamTrailers(upstream_index, *trailers);
-    }
-
-    filter->onStreamComplete();
-    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
-    pumpDispatcher();
-  }
+  void testDecodeRequestMiss(CacheFilterSharedPtr filter) {
+    // The filter should not encode any headers or data as no cached response exists.
+    EXPECT_CALL(decoder_callbacks_, encodeHeaders_).Times(0);
+    EXPECT_CALL(decoder_callbacks_, encodeData).Times(0);
 
-  void testDecodeRequestMiss(size_t upstream_index, CacheFilterSharedPtr filter) {
     // The filter should stop decoding iteration when decodeHeaders is called as a cache lookup is
     // in progress.
     EXPECT_EQ(filter->decodeHeaders(request_headers_, true),
               Http::FilterHeadersStatus::StopAllIterationAndWatermark);
 
+    // The filter should continue decoding when the cache lookup result (miss) is ready.
+    EXPECT_CALL(decoder_callbacks_, continueDecoding);
+
     // The cache lookup callback should be posted to the dispatcher.
     // Run events on the dispatcher so that the callback is invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
-    // An upstream request should be sent.
-    ASSERT_THAT(mock_upstreams_.size(), Gt(upstream_index));
-    ASSERT_THAT(mock_upstreams_headers_sent_.size(), Gt(upstream_index));
-    EXPECT_THAT(mock_upstreams_headers_sent_[upstream_index], testing::Optional(request_headers_));
+    ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
   }
 
   void testDecodeRequestHitNoBody(CacheFilterSharedPtr filter) {
@@ -242,7 +122,7 @@ protected:
 
     // The cache lookup callback should be posted to the dispatcher.
     // Run events on the dispatcher so that the callback is invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
   }
@@ -272,7 +152,7 @@ protected:
     // Run events on the dispatcher so that the callback is invoked.
     // The posted lookup callback will cause another callback to be posted (when getBody() is
     // called) which should also be invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
   }
@@ -292,9 +172,6 @@ protected:
                                                     {"cache-control", "public,max-age=3600"}};
   NiceMock<Http::MockStreamDecoderFilterCallbacks> decoder_callbacks_;
   NiceMock<Http::MockStreamEncoderFilterCallbacks> encoder_callbacks_;
-  std::vector<std::unique_ptr<Http::MockAsyncClientStream>> mock_upstreams_;
-  std::vector<std::reference_wrapper<Http::AsyncClient::StreamCallbacks>> mock_upstreams_callbacks_;
-  std::vector<absl::optional<Http::TestRequestHeaderMapImpl>> mock_upstreams_headers_sent_;
   Api::ApiPtr api_ = Api::createApiForTest();
   Event::DispatcherPtr dispatcher_ = api_->allocateDispatcher("test_thread");
   const Seconds delay_ = Seconds(10);
@@ -314,8 +191,7 @@ TEST_F(CacheFilterTest, UncacheableRequest) {
   // POST requests are uncacheable
   request_headers_.setMethod(Http::Headers::get().MethodValues.Post);
 
-  for (int request = 0; request < 2; request++) {
-    std::cerr << "  request " << request << std::endl;
+  for (int request = 1; request <= 2; request++) {
     // Create filter for the request
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
@@ -343,16 +219,15 @@ TEST_F(CacheFilterTest, UncacheableResponse) {
   // Responses with "Cache-Control: no-store" are uncacheable
   response_headers_.setReferenceKey(Http::CustomHeaders::get().CacheControl, "no-store");
 
-  for (int request = 0; request < 2; request++) {
-    std::cerr << "  request " << request << std::endl;
+  for (int request = 1; request <= 2; request++) {
     // Create filter for the request.
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
-    testDecodeRequestMiss(request, filter);
+    testDecodeRequestMiss(filter);
 
-    receiveUpstreamHeaders(request, response_headers_, true);
+    // Encode response headers.
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, true), Http::FilterHeadersStatus::Continue);
 
-    pumpDispatcher();
     filter->onStreamComplete();
     EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
     EXPECT_THAT(insertStatus(), IsOkAndHolds(InsertStatus::NoInsertResponseNotCacheable));
@@ -360,23 +235,24 @@ TEST_F(CacheFilterTest, UncacheableResponse) {
 }
 
 TEST_F(CacheFilterTest, CacheMiss) {
-  for (int request = 0; request < 2; request++) {
-    std::cerr << "  request " << request << std::endl;
+  for (int request = 1; request <= 2; request++) {
     // Each iteration a request is sent to a different host, therefore the second one is a miss
-    request_headers_.setHost(absl::StrCat("CacheMiss", request));
+    request_headers_.setHost("CacheMiss" + std::to_string(request));
 
     // Create filter for request 1
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
-    testDecodeRequestMiss(request, filter);
+    testDecodeRequestMiss(filter);
 
-    receiveUpstreamHeaders(request, response_headers_, true);
+    // Encode response header
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, true), Http::FilterHeadersStatus::Continue);
 
-    pumpDispatcher();
     filter->onStreamComplete();
     EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
     EXPECT_THAT(insertStatus(), IsOkAndHolds(InsertStatus::InsertSucceeded));
   }
+  // Clear events off the dispatcher.
+  dispatcher_->run(Event::Dispatcher::RunType::Block);
 }
 
 TEST_F(CacheFilterTest, Disabled) {
@@ -389,26 +265,28 @@ TEST_F(CacheFilterTest, CacheMissWithTrailers) {
   request_headers_.setHost("CacheMissWithTrailers");
   const std::string body = "abc";
   Buffer::OwnedImpl body_buffer(body);
-  Http::TestResponseTrailerMapImpl trailers{{"somekey", "somevalue"}};
+  Http::TestResponseTrailerMapImpl trailers;
 
-  for (int request = 0; request < 2; request++) {
-    std::cerr << "  request " << request << std::endl;
+  for (int request = 1; request <= 2; request++) {
     // Each iteration a request is sent to a different host, therefore the second one is a miss
-    request_headers_.setHost(absl::StrCat("CacheMissWithTrailers", request));
+    request_headers_.setHost("CacheMissWithTrailers" + std::to_string(request));
 
+    // Create filter for request 1
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
-    testDecodeRequestMiss(request, filter);
+    testDecodeRequestMiss(filter);
 
-    receiveUpstreamHeaders(request, response_headers_, false);
-    receiveUpstreamBody(request, body, false);
-    receiveUpstreamTrailers(request, trailers);
+    // Encode response header
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(body_buffer, false), Http::FilterDataStatus::Continue);
+    EXPECT_EQ(filter->encodeTrailers(trailers), Http::FilterTrailersStatus::Continue);
 
-    pumpDispatcher();
     filter->onStreamComplete();
     EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
     EXPECT_THAT(insertStatus(), IsOkAndHolds(InsertStatus::InsertSucceeded));
   }
+  // Clear events off the dispatcher.
+  dispatcher_->run(Event::Dispatcher::RunType::Block);
 }
 
 TEST_F(CacheFilterTest, CacheMissWithTrailersWhenCacheRespondsQuickerThanUpstream) {
@@ -417,34 +295,46 @@ TEST_F(CacheFilterTest, CacheMissWithTrailersWhenCacheRespondsQuickerThanUpstrea
   Buffer::OwnedImpl body_buffer(body);
   Http::TestResponseTrailerMapImpl trailers;
 
-  for (int request = 0; request < 2; request++) {
-    std::cerr << "  request " << request << std::endl;
+  for (int request = 1; request <= 2; request++) {
     // Each iteration a request is sent to a different host, therefore the second one is a miss
     request_headers_.setHost("CacheMissWithTrailers" + std::to_string(request));
 
     // Create filter for request 1
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
-    testDecodeRequestMiss(request, filter);
-    receiveUpstreamHeaders(request, response_headers_, false);
-    pumpDispatcher();
-    receiveUpstreamBody(request, body, false);
-    pumpDispatcher();
-    receiveUpstreamTrailers(request, trailers);
-    pumpDispatcher();
+    testDecodeRequestMiss(filter);
+
+    // Encode response header
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    // Resolve cache response
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+    EXPECT_EQ(filter->encodeData(body_buffer, false), Http::FilterDataStatus::Continue);
+    // Resolve cache response
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+    EXPECT_EQ(filter->encodeTrailers(trailers), Http::FilterTrailersStatus::Continue);
+    // Resolve cache response
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     filter->onStreamComplete();
     EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
     EXPECT_THAT(insertStatus(), IsOkAndHolds(InsertStatus::InsertSucceeded));
   }
   // Clear events off the dispatcher.
-  pumpDispatcher();
+  dispatcher_->run(Event::Dispatcher::RunType::Block);
 }
 
 TEST_F(CacheFilterTest, CacheHitNoBody) {
   request_headers_.setHost("CacheHitNoBody");
 
-  populateCommonCacheEntry(0, makeFilter(simple_cache_));
+  {
+    // Create filter for request 1.
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
+    testDecodeRequestMiss(filter);
+
+    // Encode response headers.
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, true), Http::FilterHeadersStatus::Continue);
+  }
   waitBeforeSecondRequest();
   {
     // Create filter for request 2.
@@ -462,7 +352,25 @@ TEST_F(CacheFilterTest, CacheHitWithBody) {
   request_headers_.setHost("CacheHitWithBody");
   const std::string body = "abc";
 
-  populateCommonCacheEntry(0, makeFilter(simple_cache_), body);
+  {
+    // Create filter for request 1.
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
+    testDecodeRequestMiss(filter);
+
+    // Encode response.
+    Buffer::OwnedImpl buffer(body);
+    response_headers_.setContentLength(body.size());
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(buffer, true), Http::FilterDataStatus::Continue);
+    // The cache insertBody callback should be posted to the dispatcher.
+    // Run events on the dispatcher so that the callback is invoked.
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+    EXPECT_THAT(insertStatus(), IsOkAndHolds(InsertStatus::InsertSucceeded));
+  }
   waitBeforeSecondRequest();
   {
     // Create filter for request 2
@@ -483,8 +391,18 @@ TEST_F(CacheFilterTest, WatermarkEventsAreSentIfCacheBlocksStreamAndLimitExceede
   // Set the buffer limit to 2 bytes to ensure we send watermark events.
   EXPECT_CALL(encoder_callbacks_, bufferLimit()).WillRepeatedly(::testing::Return(2));
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
-  MockInsertContext* mock_insert_context = mock_http_cache->mockInsertContext();
+  auto mock_lookup_context = std::make_unique<MockLookupContext>();
+  auto mock_insert_context = std::make_unique<MockInsertContext>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
+  EXPECT_CALL(*mock_http_cache, makeInsertContext(_, _))
+      .WillOnce([&](LookupContextPtr&&,
+                    Http::StreamEncoderFilterCallbacks&) -> std::unique_ptr<InsertContext> {
+        return std::move(mock_insert_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     dispatcher_->post([cb = std::move(cb)]() mutable { std::move(cb)(LookupResult{}, false); });
   });
@@ -506,36 +424,35 @@ TEST_F(CacheFilterTest, WatermarkEventsAreSentIfCacheBlocksStreamAndLimitExceede
         dispatcher_->post(
             [cb = std::move(ready_for_next_chunk)]() mutable { std::move(cb)(true); });
       });
+  EXPECT_CALL(*mock_insert_context, onDestroy());
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
   {
     CacheFilterSharedPtr filter = makeFilter(mock_http_cache);
 
-    testDecodeRequestMiss(0, filter);
+    testDecodeRequestMiss(filter);
 
     // Encode response.
     response_headers_.setContentLength(body1.size() + body2.size());
-    receiveUpstreamHeaders(0, response_headers_, false);
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
     // The insertHeaders callback should be posted to the dispatcher.
     // Run events on the dispatcher so that the callback is invoked.
-    pumpDispatcher();
-
-    // TODO(ravenblack): once watermarking is available in async upstreams
-    // revisit this test.
-    // EXPECT_CALL(encoder_callbacks_, onEncoderFilterAboveWriteBufferHighWatermark());
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
+    EXPECT_CALL(encoder_callbacks_, onEncoderFilterAboveWriteBufferHighWatermark());
     // Write the body in two pieces - the first one should exceed the watermark and
     // send a high watermark event.
-    receiveUpstreamBody(0, body1, false);
-    receiveUpstreamBody(0, body2, true);
+    Buffer::OwnedImpl body1buf(body1);
+    Buffer::OwnedImpl body2buf(body2);
+    EXPECT_EQ(filter->encodeData(body1buf, false), Http::FilterDataStatus::Continue);
+    EXPECT_EQ(filter->encodeData(body2buf, true), Http::FilterDataStatus::Continue);
     ASSERT_THAT(captured_insert_body_callback, NotNull());
-
-    // TODO(ravenblack): once watermarking is available in async upstreams
-    // revisit this test.
     // When the cache releases, a low watermark event should be sent.
-    // EXPECT_CALL(encoder_callbacks_, onEncoderFilterBelowWriteBufferLowWatermark());
-
+    EXPECT_CALL(encoder_callbacks_, onEncoderFilterBelowWriteBufferLowWatermark());
     captured_insert_body_callback(true);
+    // The cache insertBody callback should be posted to the dispatcher.
+    // Run events on the dispatcher so that the callback is invoked.
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
-    pumpDispatcher();
     filter->onStreamComplete();
     EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
     EXPECT_THAT(insertStatus(), IsOkAndHolds(InsertStatus::InsertSucceeded));
@@ -549,8 +466,18 @@ TEST_F(CacheFilterTest, FilterDestroyedWhileWatermarkedSendsLowWatermarkEvent) {
   // Set the buffer limit to 2 bytes to ensure we send watermark events.
   EXPECT_CALL(encoder_callbacks_, bufferLimit()).WillRepeatedly(::testing::Return(2));
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
-  MockInsertContext* mock_insert_context = mock_http_cache->mockInsertContext();
+  auto mock_lookup_context = std::make_unique<MockLookupContext>();
+  auto mock_insert_context = std::make_unique<MockInsertContext>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
+  EXPECT_CALL(*mock_http_cache, makeInsertContext(_, _))
+      .WillOnce([&](LookupContextPtr&&,
+                    Http::StreamEncoderFilterCallbacks&) -> std::unique_ptr<InsertContext> {
+        return std::move(mock_insert_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     dispatcher_->post([cb = std::move(cb)]() mutable { std::move(cb)(LookupResult{}, false); });
   });
@@ -567,40 +494,36 @@ TEST_F(CacheFilterTest, FilterDestroyedWhileWatermarkedSendsLowWatermarkEvent) {
         EXPECT_THAT(captured_insert_body_callback, IsNull());
         captured_insert_body_callback = std::move(ready_for_next_chunk);
       });
+  EXPECT_CALL(*mock_insert_context, onDestroy());
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
   {
     CacheFilterSharedPtr filter = makeFilter(mock_http_cache, false);
 
-    testDecodeRequestMiss(0, filter);
+    testDecodeRequestMiss(filter);
 
     // Encode response.
     response_headers_.setContentLength(body1.size() + body2.size());
-    receiveUpstreamHeaders(0, response_headers_, false);
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
     // The insertHeaders callback should be posted to the dispatcher.
     // Run events on the dispatcher so that the callback is invoked.
-    pumpDispatcher();
-
-    // TODO(ravenblack): enable watermark testing again once the cache filter's
-    // watermark behavior is usable. Currently this is blocked in two ways -
-    // async http streams don't support watermarking so we can't slow it down anyway,
-    // and populating the cache and streaming to the individual client are still
-    // linked, which means slowing it down for the client could also ruin the cache
-    // behavior. I intend to make the request that triggers a cache insert turn into
-    // a cache streamed read operation once the cache insert begins.
-    // EXPECT_CALL(encoder_callbacks_, onEncoderFilterAboveWriteBufferHighWatermark());
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+
+    EXPECT_CALL(encoder_callbacks_, onEncoderFilterAboveWriteBufferHighWatermark());
     // Write the body in two pieces - the first one should exceed the watermark and
     // send a high watermark event.
-    receiveUpstreamBody(0, body1, false);
-    pumpDispatcher();
-    receiveUpstreamBody(0, body2, true);
-    pumpDispatcher();
+    Buffer::OwnedImpl body1buf(body1);
+    Buffer::OwnedImpl body2buf(body2);
+    EXPECT_EQ(filter->encodeData(body1buf, false), Http::FilterDataStatus::Continue);
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+    EXPECT_EQ(filter->encodeData(body2buf, true), Http::FilterDataStatus::Continue);
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
     ASSERT_THAT(captured_insert_body_callback, NotNull());
     // When the filter is destroyed, a low watermark event should be sent.
-    // TODO(ravenblack): enable watermark testing once it works.
-    // EXPECT_CALL(encoder_callbacks_, onEncoderFilterBelowWriteBufferLowWatermark());
+    EXPECT_CALL(encoder_callbacks_, onEncoderFilterBelowWriteBufferLowWatermark());
     filter->onDestroy();
     filter.reset();
     captured_insert_body_callback(false);
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
   }
 }
 
@@ -613,7 +536,12 @@ TEST_F(CacheFilterTest, CacheEntryStreamedWithTrailersAndNoContentLengthCanDeliv
   request_headers_.setHost("CacheEntryStreamedWithTrailers");
   const std::string body = "abcde";
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
+  auto mock_lookup_context = std::make_unique<MockLookupContext>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
   // response_headers_ intentionally has no content length, LookupResult also has no content length.
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     dispatcher_->post([cb = std::move(cb), this]() mutable {
@@ -639,6 +567,7 @@ TEST_F(CacheFilterTest, CacheEntryStreamedWithTrailersAndNoContentLengthCanDeliv
       std::move(cb)(std::make_unique<Http::TestResponseTrailerMapImpl>());
     });
   });
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
   {
     CacheFilterSharedPtr filter = makeFilter(mock_http_cache);
     EXPECT_CALL(decoder_callbacks_, encodeHeaders_(IsSupersetOfHeaders(response_headers_), false));
@@ -653,7 +582,7 @@ TEST_F(CacheFilterTest, CacheEntryStreamedWithTrailersAndNoContentLengthCanDeliv
     // Run events on the dispatcher so that the callback is invoked.
     // The posted lookup callback will cause another callback to be posted (when getBody() is
     // called) which should also be invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
 
@@ -666,7 +595,12 @@ TEST_F(CacheFilterTest, CacheEntryStreamedWithTrailersAndNoContentLengthCanDeliv
 TEST_F(CacheFilterTest, OnDestroyBeforeOnHeadersAbortsAction) {
   request_headers_.setHost("CacheHitWithBody");
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
+  auto mock_lookup_context = std::make_unique<NiceMock<MockLookupContext>>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     std::unique_ptr<Http::ResponseHeaderMap> response_headers =
         std::make_unique<Http::TestResponseHeaderMapImpl>(response_headers_);
@@ -682,13 +616,18 @@ TEST_F(CacheFilterTest, OnDestroyBeforeOnHeadersAbortsAction) {
   filter->onDestroy();
   // Nothing extra should happen when the posted lookup completion resolves, because
   // the filter was destroyed.
-  pumpDispatcher();
+  dispatcher_->run(Event::Dispatcher::RunType::Block);
 }
 
 TEST_F(CacheFilterTest, OnDestroyBeforeOnBodyAbortsAction) {
   request_headers_.setHost("CacheHitWithBody");
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
+  auto mock_lookup_context = std::make_unique<NiceMock<MockLookupContext>>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     std::unique_ptr<Http::ResponseHeaderMap> response_headers =
         std::make_unique<Http::TestResponseHeaderMapImpl>(response_headers_);
@@ -703,12 +642,13 @@ TEST_F(CacheFilterTest, OnDestroyBeforeOnBodyAbortsAction) {
       .WillOnce([&](const AdjustedByteRange&, LookupBodyCallback&& cb) {
         body_callback = std::move(cb);
       });
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
   auto filter = makeFilter(mock_http_cache, false);
   EXPECT_EQ(filter->decodeHeaders(request_headers_, true),
             Http::FilterHeadersStatus::StopAllIterationAndWatermark);
   dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
   filter->onDestroy();
-  ::testing::Mock::VerifyAndClearExpectations(mock_lookup_context);
+  ::testing::Mock::VerifyAndClearExpectations(mock_lookup_context.get());
   EXPECT_THAT(body_callback, NotNull());
   // body_callback should not be called because LookupContext::onDestroy,
   // correctly implemented, should have aborted it.
@@ -717,7 +657,12 @@ TEST_F(CacheFilterTest, OnDestroyBeforeOnBodyAbortsAction) {
 TEST_F(CacheFilterTest, OnDestroyBeforeOnTrailersAbortsAction) {
   request_headers_.setHost("CacheHitWithTrailers");
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
+  auto mock_lookup_context = std::make_unique<NiceMock<MockLookupContext>>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     std::unique_ptr<Http::ResponseHeaderMap> response_headers =
         std::make_unique<Http::TestResponseHeaderMapImpl>(response_headers_);
@@ -753,7 +698,12 @@ TEST_F(CacheFilterTest, BodyReadFromCacheLimitedToBufferSizeChunks) {
   // 8 bytes.
   EXPECT_CALL(encoder_callbacks_, bufferLimit()).WillRepeatedly(::testing::Return(5));
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
+  auto mock_lookup_context = std::make_unique<MockLookupContext>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     std::unique_ptr<Http::ResponseHeaderMap> response_headers =
         std::make_unique<Http::TestResponseHeaderMapImpl>(response_headers_);
@@ -775,6 +725,7 @@ TEST_F(CacheFilterTest, BodyReadFromCacheLimitedToBufferSizeChunks) {
           std::move(cb)(std::make_unique<Buffer::OwnedImpl>("fgh"), true);
         });
       });
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
 
   CacheFilterSharedPtr filter = makeFilter(mock_http_cache, false);
 
@@ -801,7 +752,7 @@ TEST_F(CacheFilterTest, BodyReadFromCacheLimitedToBufferSizeChunks) {
   // Run events on the dispatcher so that the callback is invoked.
   // The posted lookup callback will cause another callback to be posted (when getBody() is
   // called) which should also be invoked.
-  pumpDispatcher();
+  dispatcher_->run(Event::Dispatcher::RunType::Block);
 
   filter->onDestroy();
   filter.reset();
@@ -811,8 +762,18 @@ TEST_F(CacheFilterTest, CacheInsertAbortedByCache) {
   request_headers_.setHost("CacheHitWithBody");
   const std::string body = "abc";
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
-  MockInsertContext* mock_insert_context = mock_http_cache->mockInsertContext();
+  auto mock_lookup_context = std::make_unique<MockLookupContext>();
+  auto mock_insert_context = std::make_unique<MockInsertContext>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
+  EXPECT_CALL(*mock_http_cache, makeInsertContext(_, _))
+      .WillOnce([&](LookupContextPtr&&,
+                    Http::StreamEncoderFilterCallbacks&) -> std::unique_ptr<InsertContext> {
+        return std::move(mock_insert_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     dispatcher_->post([cb = std::move(cb)]() mutable { std::move(cb)(LookupResult{}, false); });
   });
@@ -821,23 +782,27 @@ TEST_F(CacheFilterTest, CacheInsertAbortedByCache) {
                     InsertCallback insert_complete, bool) {
         dispatcher_->post([cb = std::move(insert_complete)]() mutable { std::move(cb)(true); });
       });
-  EXPECT_CALL(*mock_insert_context, insertBody(_, _, false))
+  EXPECT_CALL(*mock_insert_context, insertBody(_, _, true))
       .WillOnce([&](const Buffer::Instance&, InsertCallback ready_for_next_chunk, bool) {
         dispatcher_->post(
             [cb = std::move(ready_for_next_chunk)]() mutable { std::move(cb)(false); });
       });
+  EXPECT_CALL(*mock_insert_context, onDestroy());
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
   {
-    // Create filter for request 0.
+    // Create filter for request 1.
     CacheFilterSharedPtr filter = makeFilter(mock_http_cache);
 
-    testDecodeRequestMiss(0, filter);
+    testDecodeRequestMiss(filter);
 
     // Encode response.
+    Buffer::OwnedImpl buffer(body);
     response_headers_.setContentLength(body.size());
-    receiveUpstreamHeaders(0, response_headers_, false);
-    receiveUpstreamBody(0, body, false);
-    EXPECT_CALL(*mock_upstreams_[0], reset());
-    pumpDispatcher();
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(buffer, true), Http::FilterDataStatus::Continue);
+    // The cache insertBody callback should be posted to the dispatcher.
+    // Run events on the dispatcher so that the callback is invoked.
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     filter->onStreamComplete();
     EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
@@ -845,13 +810,23 @@ TEST_F(CacheFilterTest, CacheInsertAbortedByCache) {
   }
 }
 
-TEST_F(CacheFilterTest, FilterDestroyedWhileIncompleteCacheWriteInQueueShouldCompleteWrite) {
+TEST_F(CacheFilterTest, FilterDeletedWhileIncompleteCacheWriteInQueueShouldAbandonWrite) {
   request_headers_.setHost("CacheHitWithBody");
   const std::string body = "abc";
   auto mock_http_cache = std::make_shared<MockHttpCache>();
   std::weak_ptr<MockHttpCache> weak_cache_pointer = mock_http_cache;
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
-  MockInsertContext* mock_insert_context = mock_http_cache->mockInsertContext();
+  auto mock_lookup_context = std::make_unique<MockLookupContext>();
+  auto mock_insert_context = std::make_unique<MockInsertContext>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
+  EXPECT_CALL(*mock_http_cache, makeInsertContext(_, _))
+      .WillOnce([&](LookupContextPtr&&,
+                    Http::StreamEncoderFilterCallbacks&) -> std::unique_ptr<InsertContext> {
+        return std::move(mock_insert_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     dispatcher_->post([cb = std::move(cb)]() mutable { std::move(cb)(LookupResult{}, false); });
   });
@@ -860,47 +835,44 @@ TEST_F(CacheFilterTest, FilterDestroyedWhileIncompleteCacheWriteInQueueShouldCom
       .WillOnce([&](const Http::ResponseHeaderMap&, const ResponseMetadata&,
                     InsertCallback insert_complete,
                     bool) { captured_insert_header_callback = std::move(insert_complete); });
-  EXPECT_CALL(*mock_insert_context, insertBody(_, _, false))
-      .WillOnce([this](const Buffer::Instance&, InsertCallback insert_complete, bool) {
-        dispatcher_->post([cb = std::move(insert_complete)]() mutable { cb(true); });
-      });
-  EXPECT_CALL(*mock_insert_context, insertTrailers(_, _))
-      .WillOnce([this](const Http::ResponseTrailerMap&, InsertCallback insert_complete) {
-        dispatcher_->post([cb = std::move(insert_complete)]() mutable { cb(true); });
-      });
-
+  EXPECT_CALL(*mock_insert_context, onDestroy());
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
   {
-    // Create filter for request 0 and move the local shared_ptr,
+    // Create filter for request 1 and move the local shared_ptr,
     // transferring ownership to the filter.
     CacheFilterSharedPtr filter = makeFilter(std::move(mock_http_cache));
 
-    testDecodeRequestMiss(0, filter);
+    testDecodeRequestMiss(filter);
 
     // Encode header of response.
     response_headers_.setContentLength(body.size());
-    receiveUpstreamHeaders(0, response_headers_, false);
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
     // Destroy the filter prematurely (it goes out of scope).
   }
   ASSERT_THAT(captured_insert_header_callback, NotNull());
   EXPECT_THAT(weak_cache_pointer.lock(), NotNull())
       << "cache instance was unexpectedly destroyed when filter was destroyed";
-  // The callback should now continue to write the cache entry. Completing the
-  // write allows the UpstreamRequest and CacheInsertQueue to complete and self-destruct.
+  // The callback should now do nothing visible, because the filter has been destroyed.
+  // Calling it allows the CacheInsertQueue to discard its self-ownership.
   captured_insert_header_callback(true);
-  pumpDispatcher();
-  receiveUpstreamBodyAfterFilterDestroyed(0, body, false);
-  pumpDispatcher();
-  Http::TestResponseTrailerMapImpl trailers{{"somekey", "somevalue"}};
-  receiveUpstreamTrailersAfterFilterDestroyed(0, trailers);
-  pumpDispatcher();
 }
 
 TEST_F(CacheFilterTest, FilterDeletedWhileCompleteCacheWriteInQueueShouldContinueWrite) {
   request_headers_.setHost("CacheHitWithBody");
   const std::string body = "abc";
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
-  MockInsertContext* mock_insert_context = mock_http_cache->mockInsertContext();
+  auto mock_lookup_context = std::make_unique<MockLookupContext>();
+  auto mock_insert_context = std::make_unique<MockInsertContext>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
+  EXPECT_CALL(*mock_http_cache, makeInsertContext(_, _))
+      .WillOnce([&](LookupContextPtr&&,
+                    Http::StreamEncoderFilterCallbacks&) -> std::unique_ptr<InsertContext> {
+        return std::move(mock_insert_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     dispatcher_->post([cb = std::move(cb)]() mutable { std::move(cb)(LookupResult{}, false); });
   });
@@ -914,7 +886,20 @@ TEST_F(CacheFilterTest, FilterDeletedWhileCompleteCacheWriteInQueueShouldContinu
       .WillOnce([&](const Buffer::Instance&, InsertCallback ready_for_next_chunk, bool) {
         captured_insert_body_callback = std::move(ready_for_next_chunk);
       });
-  populateCommonCacheEntry(0, makeFilter(mock_http_cache), body);
+  EXPECT_CALL(*mock_insert_context, onDestroy());
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
+  {
+    // Create filter for request 1.
+    CacheFilterSharedPtr filter = makeFilter(mock_http_cache);
+
+    testDecodeRequestMiss(filter);
+
+    // Encode response.
+    Buffer::OwnedImpl buffer(body);
+    response_headers_.setContentLength(body.size());
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(buffer, true), Http::FilterDataStatus::Continue);
+  }
   // Header callback should be captured, body callback should not yet since the
   // queue has not reached that chunk.
   ASSERT_THAT(captured_insert_header_callback, NotNull());
@@ -924,14 +909,14 @@ TEST_F(CacheFilterTest, FilterDeletedWhileCompleteCacheWriteInQueueShouldContinu
   // Run events on the dispatcher so that the callback is invoked,
   // where it should now proceed to write the body chunk, since the
   // write is still completable.
-  pumpDispatcher();
+  dispatcher_->run(Event::Dispatcher::RunType::Block);
   // So the mock should now be writing the body.
   ASSERT_THAT(captured_insert_body_callback, NotNull());
   captured_insert_body_callback(true);
   // The callback should be posted to the dispatcher.
   // Run events on the dispatcher so that the callback is invoked,
   // where it should now do nothing due to the filter being destroyed.
-  pumpDispatcher();
+  dispatcher_->run(Event::Dispatcher::RunType::Block);
 }
 
 TEST_F(CacheFilterTest, SuccessfulValidation) {
@@ -939,13 +924,28 @@ TEST_F(CacheFilterTest, SuccessfulValidation) {
   const std::string body = "abc";
   const std::string etag = "abc123";
   const std::string last_modified_date = formatter_.now(time_source_);
+  {
+    // Create filter for request 1
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
-  // Encode response
-  // Add Etag & Last-Modified headers to the response for validation
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified, last_modified_date);
-  response_headers_.setContentLength(body.size());
-  populateCommonCacheEntry(0, makeFilter(simple_cache_), body);
+    testDecodeRequestMiss(filter);
+
+    // Encode response
+    // Add Etag & Last-Modified headers to the response for validation
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified, last_modified_date);
+
+    Buffer::OwnedImpl buffer(body);
+    response_headers_.setContentLength(body.size());
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(buffer, true), Http::FilterDataStatus::Continue);
+    // The cache getBody callback should be posted to the dispatcher.
+    // Run events on the dispatcher so that the callback is invoked.
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+  }
   waitBeforeSecondRequest();
   {
     // Create filter for request 2
@@ -957,13 +957,12 @@ TEST_F(CacheFilterTest, SuccessfulValidation) {
     // Decoding the request should find a cached response that requires validation.
     // As far as decoding the request is concerned, this is the same as a cache miss with the
     // exception of injecting validation precondition headers.
-    testDecodeRequestMiss(1, filter);
+    testDecodeRequestMiss(filter);
 
     // Make sure validation conditional headers are added
     const Http::TestRequestHeaderMapImpl injected_headers = {
         {"if-none-match", etag}, {"if-modified-since", last_modified_date}};
-    EXPECT_THAT(mock_upstreams_headers_sent_[1],
-                testing::Optional(IsSupersetOfHeaders(injected_headers)));
+    EXPECT_THAT(request_headers_, IsSupersetOfHeaders(injected_headers));
 
     // Encode 304 response
     // Advance time to make sure the cached date is updated with the 304 date
@@ -971,26 +970,33 @@ TEST_F(CacheFilterTest, SuccessfulValidation) {
     Http::TestResponseHeaderMapImpl not_modified_response_headers = {{":status", "304"},
                                                                      {"date", not_modified_date}};
 
-    // Receiving the 304 response should result in sending the merged headers with
-    // updated date.
-    Http::TestResponseHeaderMapImpl expected_response_headers = response_headers_;
-    expected_response_headers.setDate(not_modified_date);
+    // The filter should stop encoding iteration when encodeHeaders is called as a cached response
+    // is being fetched and added to the encoding stream. StopIteration does not stop encodeData of
+    // the same filter from being called
+    EXPECT_EQ(filter->encodeHeaders(not_modified_response_headers, true),
+              Http::FilterHeadersStatus::StopIteration);
 
-    // The upstream should be reset on not_modified
-    receiveUpstreamHeadersWithReset(1, not_modified_response_headers, true,
-                                    IsSupersetOfHeaders(expected_response_headers));
+    // Check for the cached response headers with updated date
+    Http::TestResponseHeaderMapImpl updated_response_headers = response_headers_;
+    updated_response_headers.setDate(not_modified_date);
+    EXPECT_THAT(not_modified_response_headers, IsSupersetOfHeaders(updated_response_headers));
 
-    // It should be impossible for onData to be called on the upstream after reset
-    // has been called on it.
+    // A 304 response should not have a body, so encodeData should not be called
+    // However, if a body is present by mistake, encodeData should stop iteration until
+    // encoding the cached response is done
+    Buffer::OwnedImpl not_modified_body;
+    EXPECT_EQ(filter->encodeData(not_modified_body, true),
+              Http::FilterDataStatus::StopIterationAndBuffer);
 
     // The filter should add the cached response body to encoded data.
+    Buffer::OwnedImpl buffer(body);
     EXPECT_CALL(
-        decoder_callbacks_,
-        encodeData(testing::Property(&Buffer::Instance::toString, testing::Eq(body)), true));
+        encoder_callbacks_,
+        addEncodedData(testing::Property(&Buffer::Instance::toString, testing::Eq(body)), true));
 
     // The cache getBody callback should be posted to the dispatcher.
     // Run events on the dispatcher so that the callback is invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     ::testing::Mock::VerifyAndClearExpectations(&encoder_callbacks_);
 
@@ -1005,16 +1011,32 @@ TEST_F(CacheFilterTest, SuccessfulValidationWithFilterDestroyedDuringContinueEnc
   const std::string body = "abc";
   const std::string etag = "abc123";
   const std::string last_modified_date = formatter_.now(time_source_);
-  // Encode response
-  // Add Etag & Last-Modified headers to the response for validation
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified, last_modified_date);
-  response_headers_.setContentLength(body.size());
-  populateCommonCacheEntry(0, makeFilter(simple_cache_), body);
+  {
+    // Create filter for request 1
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
+    testDecodeRequestMiss(filter);
+
+    // Encode response
+    // Add Etag & Last-Modified headers to the response for validation
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified, last_modified_date);
+
+    Buffer::OwnedImpl buffer(body);
+    response_headers_.setContentLength(body.size());
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(buffer, true), Http::FilterDataStatus::Continue);
+    // The cache getBody callback should be posted to the dispatcher.
+    // Run events on the dispatcher so that the callback is invoked.
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+  }
   waitBeforeSecondRequest();
   {
     // Create filter for request 2
-    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_, /*auto_destroy=*/false);
 
     // Make request require validation
     request_headers_.setReferenceKey(Http::CustomHeaders::get().CacheControl, "no-cache");
@@ -1022,13 +1044,12 @@ TEST_F(CacheFilterTest, SuccessfulValidationWithFilterDestroyedDuringContinueEnc
     // Decoding the request should find a cached response that requires validation.
     // As far as decoding the request is concerned, this is the same as a cache miss with the
     // exception of injecting validation precondition headers.
-    testDecodeRequestMiss(1, filter);
+    testDecodeRequestMiss(filter);
 
     // Make sure validation conditional headers are added
     const Http::TestRequestHeaderMapImpl injected_headers = {
         {"if-none-match", etag}, {"if-modified-since", last_modified_date}};
-    EXPECT_THAT(mock_upstreams_headers_sent_[1],
-                testing::Optional(IsSupersetOfHeaders(injected_headers)));
+    EXPECT_THAT(request_headers_, IsSupersetOfHeaders(injected_headers));
 
     // Encode 304 response
     // Advance time to make sure the cached date is updated with the 304 date
@@ -1036,24 +1057,34 @@ TEST_F(CacheFilterTest, SuccessfulValidationWithFilterDestroyedDuringContinueEnc
     Http::TestResponseHeaderMapImpl not_modified_response_headers = {{":status", "304"},
                                                                      {"date", not_modified_date}};
 
-    // Check for the cached response headers with updated date
-    Http::TestResponseHeaderMapImpl expected_response_headers = response_headers_;
-    expected_response_headers.setDate(not_modified_date);
+    // The filter should stop encoding iteration when encodeHeaders is called as a cached response
+    // is being fetched and added to the encoding stream. StopIteration does not stop encodeData of
+    // the same filter from being called
+    EXPECT_EQ(filter->encodeHeaders(not_modified_response_headers, true),
+              Http::FilterHeadersStatus::StopIteration);
 
-    // The upstream should be reset on not_modified
-    receiveUpstreamHeadersWithReset(1, not_modified_response_headers, true,
-                                    IsSupersetOfHeaders(expected_response_headers));
+    // Check for the cached response headers with updated date
+    Http::TestResponseHeaderMapImpl updated_response_headers = response_headers_;
+    updated_response_headers.setDate(not_modified_date);
+    EXPECT_THAT(not_modified_response_headers, IsSupersetOfHeaders(updated_response_headers));
 
-    // It should be impossible for onBody to be called after reset was called.
+    // A 304 response should not have a body, so encodeData should not be called
+    // However, if a body is present by mistake, encodeData should stop iteration until
+    // encoding the cached response is done
+    Buffer::OwnedImpl not_modified_body;
+    EXPECT_EQ(filter->encodeData(not_modified_body, true),
+              Http::FilterDataStatus::StopIterationAndBuffer);
 
     // The filter should add the cached response body to encoded data.
+    Buffer::OwnedImpl buffer(body);
     EXPECT_CALL(
-        decoder_callbacks_,
-        encodeData(testing::Property(&Buffer::Instance::toString, testing::Eq(body)), true));
+        encoder_callbacks_,
+        addEncodedData(testing::Property(&Buffer::Instance::toString, testing::Eq(body)), true));
+    EXPECT_CALL(encoder_callbacks_, continueEncoding()).WillOnce([&]() { filter->onDestroy(); });
 
     // The cache getBody callback should be posted to the dispatcher.
     // Run events on the dispatcher so that the callback is invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     ::testing::Mock::VerifyAndClearExpectations(&encoder_callbacks_);
   }
@@ -1064,15 +1095,31 @@ TEST_F(CacheFilterTest, UnsuccessfulValidation) {
   const std::string body = "abc";
   const std::string etag = "abc123";
   const std::string last_modified_date = formatter_.now(time_source_);
-  // Encode response
-  // Add Etag & Last-Modified headers to the response for validation.
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified, last_modified_date);
-  response_headers_.setContentLength(body.size());
-  populateCommonCacheEntry(0, makeFilter(simple_cache_), body);
+  {
+    // Create filter for request 1
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
+    testDecodeRequestMiss(filter);
+
+    // Encode response
+    // Add Etag & Last-Modified headers to the response for validation.
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified, last_modified_date);
+
+    Buffer::OwnedImpl buffer(body);
+    response_headers_.setContentLength(body.size());
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(buffer, true), Http::FilterDataStatus::Continue);
+    // The cache getBody callback should be posted to the dispatcher.
+    // Run events on the dispatcher so that the callback is invoked.
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+  }
   waitBeforeSecondRequest();
   {
-    // Create filter for request 1.
+    // Create filter for request 2.
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
     // Make request require validation
@@ -1081,22 +1128,21 @@ TEST_F(CacheFilterTest, UnsuccessfulValidation) {
     // Decoding the request should find a cached response that requires validation.
     // As far as decoding the request is concerned, this is the same as a cache miss with the
     // exception of injecting validation precondition headers.
-    testDecodeRequestMiss(1, filter);
+    testDecodeRequestMiss(filter);
 
     // Make sure validation conditional headers are added.
     const Http::TestRequestHeaderMapImpl injected_headers = {
         {"if-none-match", etag}, {"if-modified-since", last_modified_date}};
-    EXPECT_THAT(mock_upstreams_headers_sent_[1],
-                testing::Optional(IsSupersetOfHeaders(injected_headers)));
+    EXPECT_THAT(request_headers_, IsSupersetOfHeaders(injected_headers));
 
     // Encode new response.
     // Change the status code to make sure new headers are served, not the cached ones.
     response_headers_.setStatus(204);
 
     // The filter should not stop encoding iteration as this is a new response.
-    receiveUpstreamHeaders(1, response_headers_, false);
-    std::string new_body = "";
-    receiveUpstreamBody(1, new_body, true);
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    Buffer::OwnedImpl new_body;
+    EXPECT_EQ(filter->encodeData(new_body, true), Http::FilterDataStatus::Continue);
 
     // The response headers should have the new status.
     EXPECT_THAT(response_headers_, ContainsHeader(Http::Headers::get().Status, "204"));
@@ -1106,7 +1152,7 @@ TEST_F(CacheFilterTest, UnsuccessfulValidation) {
 
     // If a cache getBody callback is made, it should be posted to the dispatcher.
     // Run events on the dispatcher so that any available callbacks are invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     ::testing::Mock::VerifyAndClearExpectations(&encoder_callbacks_);
 
@@ -1119,8 +1165,25 @@ TEST_F(CacheFilterTest, UnsuccessfulValidation) {
 TEST_F(CacheFilterTest, SingleSatisfiableRange) {
   request_headers_.setHost("SingleSatisfiableRange");
   const std::string body = "abc";
-  response_headers_.setContentLength(body.size());
-  populateCommonCacheEntry(0, makeFilter(simple_cache_), body);
+
+  {
+    // Create filter for request 1.
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
+    testDecodeRequestMiss(filter);
+
+    // Encode response.
+    Buffer::OwnedImpl buffer(body);
+    response_headers_.setContentLength(body.size());
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(buffer, true), Http::FilterDataStatus::Continue);
+    // The cache getBody callback should be posted to the dispatcher.
+    // Run events on the dispatcher so that the callback is invoked.
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+  }
   waitBeforeSecondRequest();
   {
     // Add range info to headers.
@@ -1149,7 +1212,7 @@ TEST_F(CacheFilterTest, SingleSatisfiableRange) {
     // Run events on the dispatcher so that the callback is invoked.
     // The posted lookup callback will cause another callback to be posted (when getBody() is
     // called) which should also be invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
 
@@ -1162,8 +1225,25 @@ TEST_F(CacheFilterTest, SingleSatisfiableRange) {
 TEST_F(CacheFilterTest, MultipleSatisfiableRanges) {
   request_headers_.setHost("MultipleSatisfiableRanges");
   const std::string body = "abc";
-  response_headers_.setContentLength(body.size());
-  populateCommonCacheEntry(0, makeFilter(simple_cache_), body);
+
+  {
+    // Create filter for request 1
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
+    testDecodeRequestMiss(filter);
+
+    // Encode response header
+    Buffer::OwnedImpl buffer(body);
+    response_headers_.setContentLength(body.size());
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(buffer, true), Http::FilterDataStatus::Continue);
+    // The cache getBody callback should be posted to the dispatcher.
+    // Run events on the dispatcher so that the callback is invoked.
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+  }
   waitBeforeSecondRequest();
   {
     // Add range info to headers
@@ -1189,7 +1269,7 @@ TEST_F(CacheFilterTest, MultipleSatisfiableRanges) {
     // Run events on the dispatcher so that the callback is invoked.
     // The posted lookup callback will cause another callback to be posted (when getBody() is
     // called) which should also be invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
 
@@ -1201,8 +1281,25 @@ TEST_F(CacheFilterTest, MultipleSatisfiableRanges) {
 TEST_F(CacheFilterTest, NotSatisfiableRange) {
   request_headers_.setHost("NotSatisfiableRange");
   const std::string body = "abc";
-  response_headers_.setContentLength(body.size());
-  populateCommonCacheEntry(0, makeFilter(simple_cache_), body);
+
+  {
+    // Create filter for request 1
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
+    testDecodeRequestMiss(filter);
+
+    // Encode response header
+    Buffer::OwnedImpl buffer(body);
+    response_headers_.setContentLength(body.size());
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, false), Http::FilterHeadersStatus::Continue);
+    EXPECT_EQ(filter->encodeData(buffer, true), Http::FilterDataStatus::Continue);
+    // The cache getBody callback should be posted to the dispatcher.
+    // Run events on the dispatcher so that the callback is invoked.
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+  }
   waitBeforeSecondRequest();
   {
     // Add range info to headers
@@ -1233,7 +1330,7 @@ TEST_F(CacheFilterTest, NotSatisfiableRange) {
     // Run events on the dispatcher so that the callback is invoked.
     // The posted lookup callback will cause another callback to be posted (when getBody() is
     // called) which should also be invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     // This counts as a cache hit: we served an HTTP error, but we
     // correctly got that info from the cache instead of upstream.
@@ -1273,11 +1370,22 @@ TEST_F(CacheFilterTest, GetRequestWithBodyAndTrailers) {
 // reliably fail if the CacheFilter is accessed after being deleted.
 TEST_F(CacheFilterTest, FilterDeletedBeforePostedCallbackExecuted) {
   request_headers_.setHost("FilterDeletedBeforePostedCallbackExecuted");
-  populateCommonCacheEntry(0, makeFilter(simple_cache_));
   {
     // Create filter for request 1.
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
+    testDecodeRequestMiss(filter);
+
+    // Encode response headers.
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, true), Http::FilterHeadersStatus::Continue);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+  }
+  {
+    // Create filter for request 2.
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
     // Call decode headers to start the cache lookup, which should immediately post the callback to
     // the dispatcher.
     EXPECT_EQ(filter->decodeHeaders(request_headers_, true),
@@ -1293,18 +1401,29 @@ TEST_F(CacheFilterTest, FilterDeletedBeforePostedCallbackExecuted) {
   EXPECT_CALL(decoder_callbacks_, encodeHeaders_).Times(0);
 
   // Run events on the dispatcher so that the callback is invoked after the filter deletion.
-  pumpDispatcher();
+  dispatcher_->run(Event::Dispatcher::RunType::Block);
 
   ::testing::Mock::VerifyAndClearExpectations(&decoder_callbacks_);
 }
 
 TEST_F(CacheFilterTest, LocalReplyDuringLookup) {
   request_headers_.setHost("LocalReplyDuringLookup");
-  populateCommonCacheEntry(0, makeFilter(simple_cache_));
   {
     // Create filter for request 1.
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
+    testDecodeRequestMiss(filter);
+
+    // Encode response headers.
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, true), Http::FilterHeadersStatus::Continue);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+  }
+  {
+    // Create filter for request 2.
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
     // Call decode headers to start the cache lookup, which should immediately post the callback to
     // the dispatcher.
     EXPECT_EQ(filter->decodeHeaders(request_headers_, true),
@@ -1321,7 +1440,7 @@ TEST_F(CacheFilterTest, LocalReplyDuringLookup) {
     EXPECT_CALL(decoder_callbacks_, encodeHeaders_).Times(0);
 
     // Run events on the dispatcher so that the lookup callback is invoked after the local reply.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
 
     filter->onStreamComplete();
     EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::RequestIncomplete));
@@ -1335,7 +1454,12 @@ using CacheFilterDeathTest = CacheFilterTest;
 TEST_F(CacheFilterDeathTest, BadRangeRequestLookup) {
   request_headers_.setHost("BadRangeRequestLookup");
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
+  auto mock_lookup_context = std::make_unique<MockLookupContext>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     dispatcher_->post([cb = std::move(cb), this]() mutable {
       // LookupResult with unknown length and an unsatisfiable RangeDetails is invalid.
@@ -1347,6 +1471,7 @@ TEST_F(CacheFilterDeathTest, BadRangeRequestLookup) {
           false);
     });
   });
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
   {
     CacheFilterSharedPtr filter = makeFilter(mock_http_cache);
     // encodeHeaders can be called when ENVOY_BUG doesn't exit.
@@ -1360,7 +1485,7 @@ TEST_F(CacheFilterDeathTest, BadRangeRequestLookup) {
     // The cache lookup callback should be posted to the dispatcher.
     // Run events on the dispatcher so that the callback is invoked.
     EXPECT_ENVOY_BUG(
-        pumpDispatcher(),
+        dispatcher_->run(Event::Dispatcher::RunType::Block),
         "handleCacheHitWithRangeRequest() should not be called with satisfiable_=false");
   }
 }
@@ -1369,7 +1494,12 @@ TEST_F(CacheFilterTest, RangeRequestSatisfiedBeforeLengthKnown) {
   request_headers_.setHost("RangeRequestSatisfiedBeforeLengthKnown");
   std::string body = "abcde";
   auto mock_http_cache = std::make_shared<MockHttpCache>();
-  MockLookupContext* mock_lookup_context = mock_http_cache->mockLookupContext();
+  auto mock_lookup_context = std::make_unique<MockLookupContext>();
+  EXPECT_CALL(*mock_http_cache, makeLookupContext(_, _))
+      .WillOnce([&](LookupRequest&&,
+                    Http::StreamDecoderFilterCallbacks&) -> std::unique_ptr<LookupContext> {
+        return std::move(mock_lookup_context);
+      });
   EXPECT_CALL(*mock_lookup_context, getHeaders(_)).WillOnce([&](LookupHeadersCallback&& cb) {
     // LookupResult with unknown length and an unsatisfiable RangeDetails is invalid.
     dispatcher_->post([cb = std::move(cb), this]() mutable {
@@ -1387,6 +1517,7 @@ TEST_F(CacheFilterTest, RangeRequestSatisfiedBeforeLengthKnown) {
           cb(std::make_unique<Buffer::OwnedImpl>(body), false);
         });
       });
+  EXPECT_CALL(*mock_lookup_context, onDestroy());
   {
     CacheFilterSharedPtr filter = makeFilter(mock_http_cache);
     response_headers_ = {{":status", "206"}, {"content-range", "bytes 0-4/*"}};
@@ -1398,13 +1529,24 @@ TEST_F(CacheFilterTest, RangeRequestSatisfiedBeforeLengthKnown) {
 
     // The cache lookup callback should be posted to the dispatcher.
     // Run events on the dispatcher so that the callback is invoked.
-    pumpDispatcher();
+    dispatcher_->run(Event::Dispatcher::RunType::Block);
   }
 }
 
 TEST_F(CacheFilterDeathTest, StreamTimeoutDuringLookup) {
   request_headers_.setHost("StreamTimeoutDuringLookup");
-  populateCommonCacheEntry(0, makeFilter(simple_cache_));
+  {
+    // Create filter for request 1.
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+
+    testDecodeRequestMiss(filter);
+
+    // Encode response headers.
+    EXPECT_EQ(filter->encodeHeaders(response_headers_, true), Http::FilterHeadersStatus::Continue);
+
+    filter->onStreamComplete();
+    EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::CacheMiss));
+  }
   Envoy::Http::TestResponseHeaderMapImpl local_response_headers{{":status", "408"}};
   EXPECT_ENVOY_BUG(
       {
@@ -1427,7 +1569,7 @@ TEST_F(CacheFilterDeathTest, StreamTimeoutDuringLookup) {
         // As a death test when ENVOY_BUG crashes, as in debug builds, this will exit here,
         // so we must not perform any required cleanup operations below this point in the block.
         // When ENVOY_BUG does not crash, we can still validate additional things.
-        pumpDispatcher();
+        dispatcher_->run(Event::Dispatcher::RunType::Block);
 
         filter->onStreamComplete();
         EXPECT_THAT(lookupStatus(), IsOkAndHolds(LookupStatus::RequestIncomplete));
@@ -1435,7 +1577,7 @@ TEST_F(CacheFilterDeathTest, StreamTimeoutDuringLookup) {
       "Request timed out while cache lookup was outstanding.");
 
   // Clear out captured lookup lambdas from the dispatcher.
-  pumpDispatcher();
+  dispatcher_->run(Event::Dispatcher::RunType::Block);
 }
 
 TEST(LookupStatusDeathTest, ResolveLookupStatusRequireValidationAndInitialIsBug) {
@@ -1444,6 +1586,12 @@ TEST(LookupStatusDeathTest, ResolveLookupStatusRequireValidationAndInitialIsBug)
       "Unexpected filter state in requestCacheStatus");
 }
 
+TEST(LookupStatusDeathTest, ResolveLookupStatusRequireValidationAndDecodeServingFromCacheIsBug) {
+  EXPECT_ENVOY_BUG(CacheFilter::resolveLookupStatus(CacheEntryStatus::RequiresValidation,
+                                                    FilterState::DecodeServingFromCache),
+                   "Unexpected filter state in requestCacheStatus");
+}
+
 TEST(LookupStatusDeathTest, ResolveLookupStatusRequireValidationAndDestroyedIsBug) {
   EXPECT_ENVOY_BUG(CacheFilter::resolveLookupStatus(CacheEntryStatus::RequiresValidation,
                                                     FilterState::Destroyed),
@@ -1459,7 +1607,9 @@ TEST(LookupStatusTest, ResolveLookupStatusReturnsCorrectStatuses) {
             LookupStatus::Unknown);
   EXPECT_EQ(CacheFilter::resolveLookupStatus(absl::nullopt, FilterState::ValidatingCachedResponse),
             LookupStatus::Unknown);
-  EXPECT_EQ(CacheFilter::resolveLookupStatus(absl::nullopt, FilterState::ServingFromCache),
+  EXPECT_EQ(CacheFilter::resolveLookupStatus(absl::nullopt, FilterState::DecodeServingFromCache),
+            LookupStatus::Unknown);
+  EXPECT_EQ(CacheFilter::resolveLookupStatus(absl::nullopt, FilterState::EncodeServingFromCache),
             LookupStatus::Unknown);
   EXPECT_EQ(CacheFilter::resolveLookupStatus(absl::nullopt, FilterState::Destroyed),
             LookupStatus::Unknown);
@@ -1467,7 +1617,7 @@ TEST(LookupStatusTest, ResolveLookupStatusReturnsCorrectStatuses) {
                                              FilterState::ValidatingCachedResponse),
             LookupStatus::RequestIncomplete);
   EXPECT_EQ(CacheFilter::resolveLookupStatus(CacheEntryStatus::RequiresValidation,
-                                             FilterState::ServingFromCache),
+                                             FilterState::EncodeServingFromCache),
             LookupStatus::StaleHitWithSuccessfulValidation);
   EXPECT_EQ(CacheFilter::resolveLookupStatus(CacheEntryStatus::RequiresValidation,
                                              FilterState::ResponseServedFromCache),
@@ -1488,156 +1638,143 @@ using ValidationHeadersTest = CacheFilterTest;
 TEST_F(ValidationHeadersTest, EtagAndLastModified) {
   request_headers_.setHost("EtagAndLastModified");
   const std::string etag = "abc123";
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified,
-                                    formatter_.now(time_source_));
-  populateCommonCacheEntry(0, makeFilter(simple_cache_));
+
+  // Make request 1 to insert the response into cache
+  {
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+    testDecodeRequestMiss(filter);
+
+    // Add validation headers to the response
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified,
+                                      formatter_.now(time_source_));
+
+    filter->encodeHeaders(response_headers_, true);
+  }
+  // Make request 2 to test for added conditional headers
   {
-    // Make request 1 to test for added conditional headers
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
     // Make sure the request requires validation
     request_headers_.setReferenceKey(Http::CustomHeaders::get().CacheControl, "no-cache");
-    testDecodeRequestMiss(1, filter);
+    testDecodeRequestMiss(filter);
 
     // Make sure validation conditional headers are added
     const Http::TestRequestHeaderMapImpl injected_headers = {
         {"if-none-match", "abc123"}, {"if-modified-since", formatter_.now(time_source_)}};
-    EXPECT_THAT(mock_upstreams_headers_sent_[1],
-                testing::Optional(IsSupersetOfHeaders(injected_headers)));
+    EXPECT_THAT(request_headers_, IsSupersetOfHeaders(injected_headers));
   }
 }
 
 TEST_F(ValidationHeadersTest, EtagOnly) {
   request_headers_.setHost("EtagOnly");
   const std::string etag = "abc123";
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
-  populateCommonCacheEntry(0, makeFilter(simple_cache_));
+
+  // Make request 1 to insert the response into cache
+  {
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+    testDecodeRequestMiss(filter);
+
+    // Add validation headers to the response
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().Etag, etag);
+
+    filter->encodeHeaders(response_headers_, true);
+  }
+  // Make request 2 to test for added conditional headers
   {
-    // Make request 1 to test for added conditional headers
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
     // Make sure the request requires validation
     request_headers_.setReferenceKey(Http::CustomHeaders::get().CacheControl, "no-cache");
-    testDecodeRequestMiss(1, filter);
+    testDecodeRequestMiss(filter);
 
     // Make sure validation conditional headers are added
     // If-Modified-Since falls back to date
     const Http::TestRequestHeaderMapImpl injected_headers = {
         {"if-none-match", "abc123"}, {"if-modified-since", formatter_.now(time_source_)}};
-    EXPECT_THAT(mock_upstreams_headers_sent_[1],
-                testing::Optional(IsSupersetOfHeaders(injected_headers)));
+    EXPECT_THAT(request_headers_, IsSupersetOfHeaders(injected_headers));
   }
 }
 
 TEST_F(ValidationHeadersTest, LastModifiedOnly) {
   request_headers_.setHost("LastModifiedOnly");
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified,
-                                    formatter_.now(time_source_));
-  populateCommonCacheEntry(0, makeFilter(simple_cache_));
+
+  // Make request 1 to insert the response into cache
+  {
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+    testDecodeRequestMiss(filter);
+
+    // Add validation headers to the response
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified,
+                                      formatter_.now(time_source_));
+
+    filter->encodeHeaders(response_headers_, true);
+  }
+  // Make request 2 to test for added conditional headers
   {
-    // Make request 2 to test for added conditional headers
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
     // Make sure the request requires validation
     request_headers_.setReferenceKey(Http::CustomHeaders::get().CacheControl, "no-cache");
-    testDecodeRequestMiss(1, filter);
+    testDecodeRequestMiss(filter);
 
     // Make sure validation conditional headers are added
     const Http::TestRequestHeaderMapImpl injected_headers = {
         {"if-modified-since", formatter_.now(time_source_)}};
-    EXPECT_THAT(mock_upstreams_headers_sent_[1],
-                testing::Optional(IsSupersetOfHeaders(injected_headers)));
+    EXPECT_THAT(request_headers_, IsSupersetOfHeaders(injected_headers));
   }
 }
 
 TEST_F(ValidationHeadersTest, NoEtagOrLastModified) {
   request_headers_.setHost("NoEtagOrLastModified");
-  populateCommonCacheEntry(0, makeFilter(simple_cache_));
+
+  // Make request 1 to insert the response into cache
+  {
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+    testDecodeRequestMiss(filter);
+    filter->encodeHeaders(response_headers_, true);
+  }
+  // Make request 2 to test for added conditional headers
   {
-    // Make request 2 to test for added conditional headers
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
     // Make sure the request requires validation
     request_headers_.setReferenceKey(Http::CustomHeaders::get().CacheControl, "no-cache");
-    testDecodeRequestMiss(1, filter);
+    testDecodeRequestMiss(filter);
 
     // Make sure validation conditional headers are added
     // If-Modified-Since falls back to date
     const Http::TestRequestHeaderMapImpl injected_headers = {
         {"if-modified-since", formatter_.now(time_source_)}};
-    EXPECT_THAT(mock_upstreams_headers_sent_[1],
-                testing::Optional(IsSupersetOfHeaders(injected_headers)));
+    EXPECT_THAT(request_headers_, IsSupersetOfHeaders(injected_headers));
   }
 }
 
 TEST_F(ValidationHeadersTest, InvalidLastModified) {
   request_headers_.setHost("InvalidLastModified");
-  response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified, "invalid-date");
-  populateCommonCacheEntry(0, makeFilter(simple_cache_));
+
+  // Make request 1 to insert the response into cache
+  {
+    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
+    testDecodeRequestMiss(filter);
+
+    // Add validation headers to the response
+    response_headers_.setReferenceKey(Http::CustomHeaders::get().LastModified, "invalid-date");
+    filter->encodeHeaders(response_headers_, true);
+  }
+  // Make request 2 to test for added conditional headers
   {
-    // Make request 1 to test for added conditional headers
     CacheFilterSharedPtr filter = makeFilter(simple_cache_);
 
     // Make sure the request requires validation
     request_headers_.setReferenceKey(Http::CustomHeaders::get().CacheControl, "no-cache");
-    testDecodeRequestMiss(1, filter);
+    testDecodeRequestMiss(filter);
 
     // Make sure validation conditional headers are added
     // If-Modified-Since falls back to date
     const Http::TestRequestHeaderMapImpl injected_headers = {
         {"if-modified-since", formatter_.now(time_source_)}};
-    EXPECT_THAT(mock_upstreams_headers_sent_[1],
-                testing::Optional(IsSupersetOfHeaders(injected_headers)));
-  }
-}
-
-TEST_F(CacheFilterTest, NoRouteShouldLocalReply) {
-  request_headers_.setHost("NoRoute");
-  EXPECT_CALL(decoder_callbacks_, route()).WillOnce(Return(nullptr));
-  {
-    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
-    // The filter should stop decoding iteration when decodeHeaders is called as a cache lookup is
-    // in progress.
-    EXPECT_EQ(filter->decodeHeaders(request_headers_, true),
-              Http::FilterHeadersStatus::StopAllIterationAndWatermark);
-    EXPECT_CALL(decoder_callbacks_,
-                sendLocalReply(Http::Code::NotFound, _, _, _, "cache_no_route"));
-    // The cache lookup callback should be posted to the dispatcher.
-    // Run events on the dispatcher so that the callback is invoked.
-    pumpDispatcher();
-  }
-}
-
-TEST_F(CacheFilterTest, NoClusterShouldLocalReply) {
-  request_headers_.setHost("NoCluster");
-  EXPECT_CALL(context_.server_factory_context_.cluster_manager_, getThreadLocalCluster(_))
-      .WillOnce(Return(nullptr));
-  {
-    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
-    // The filter should stop decoding iteration when decodeHeaders is called as a cache lookup is
-    // in progress.
-    EXPECT_EQ(filter->decodeHeaders(request_headers_, true),
-              Http::FilterHeadersStatus::StopAllIterationAndWatermark);
-    EXPECT_CALL(decoder_callbacks_,
-                sendLocalReply(Http::Code::ServiceUnavailable, _, _, _, "cache_no_cluster"));
-    // The cache lookup callback should be posted to the dispatcher.
-    // Run events on the dispatcher so that the callback is invoked.
-    pumpDispatcher();
-  }
-}
-
-TEST_F(CacheFilterTest, UpstreamResetMidResponseShouldLocalReply) {
-  request_headers_.setHost("UpstreamResetMidResponse");
-  {
-    CacheFilterSharedPtr filter = makeFilter(simple_cache_);
-    testDecodeRequestMiss(0, filter);
-    receiveUpstreamHeaders(0, response_headers_, false);
-    pumpDispatcher();
-    EXPECT_CALL(decoder_callbacks_,
-                sendLocalReply(Http::Code::ServiceUnavailable, _, _, _, "cache_upstream_reset"));
-    mock_upstreams_callbacks_[0].get().onReset();
-    pumpDispatcher();
+    EXPECT_THAT(request_headers_, IsSupersetOfHeaders(injected_headers));
   }
 }
 
diff --git test/extensions/filters/http/cache/mocks.h test/extensions/filters/http/cache/mocks.h
index 57ee46266b..d1739f9584 100644
--- test/extensions/filters/http/cache/mocks.h
+++ test/extensions/filters/http/cache/mocks.h
@@ -9,6 +9,18 @@ namespace Extensions {
 namespace HttpFilters {
 namespace Cache {
 
+class MockHttpCache : public HttpCache {
+public:
+  MOCK_METHOD(LookupContextPtr, makeLookupContext,
+              (LookupRequest && request, Http::StreamDecoderFilterCallbacks& callbacks));
+  MOCK_METHOD(InsertContextPtr, makeInsertContext,
+              (LookupContextPtr && lookup_context, Http::StreamEncoderFilterCallbacks& callbacks));
+  MOCK_METHOD(void, updateHeaders,
+              (const LookupContext& lookup_context, const Http::ResponseHeaderMap& response_headers,
+               const ResponseMetadata& metadata, absl::AnyInvocable<void(bool)> on_complete));
+  MOCK_METHOD(CacheInfo, cacheInfo, (), (const));
+};
+
 class MockLookupContext : public LookupContext {
 public:
   MOCK_METHOD(void, getHeaders, (LookupHeadersCallback && cb));
@@ -30,47 +42,6 @@ public:
   MOCK_METHOD(void, onDestroy, ());
 };
 
-class MockHttpCache : public HttpCache {
-public:
-  MOCK_METHOD(LookupContextPtr, makeLookupContext,
-              (LookupRequest && request, Http::StreamFilterCallbacks& callbacks));
-  MOCK_METHOD(InsertContextPtr, makeInsertContext,
-              (LookupContextPtr && lookup_context, Http::StreamFilterCallbacks& callbacks));
-  MOCK_METHOD(void, updateHeaders,
-              (const LookupContext& lookup_context, const Http::ResponseHeaderMap& response_headers,
-               const ResponseMetadata& metadata, absl::AnyInvocable<void(bool)> on_complete));
-  MOCK_METHOD(CacheInfo, cacheInfo, (), (const));
-  MockLookupContext* mockLookupContext() {
-    ASSERT(mock_lookup_context_ == nullptr);
-    mock_lookup_context_ = std::make_unique<MockLookupContext>();
-    EXPECT_CALL(*mock_lookup_context_, onDestroy());
-    EXPECT_CALL(*this, makeLookupContext)
-        .WillOnce([this](LookupRequest&&,
-                         Http::StreamFilterCallbacks&) -> std::unique_ptr<LookupContext> {
-          auto ret = std::move(mock_lookup_context_);
-          mock_lookup_context_ = nullptr;
-          return ret;
-        });
-    return mock_lookup_context_.get();
-  }
-  MockInsertContext* mockInsertContext() {
-    ASSERT(mock_insert_context_ == nullptr);
-    mock_insert_context_ = std::make_unique<MockInsertContext>();
-    EXPECT_CALL(*mock_insert_context_, onDestroy());
-    EXPECT_CALL(*this, makeInsertContext)
-        .WillOnce([this](LookupContextPtr&& lookup_context,
-                         Http::StreamFilterCallbacks&) -> std::unique_ptr<InsertContext> {
-          lookup_context->onDestroy();
-          auto ret = std::move(mock_insert_context_);
-          mock_insert_context_ = nullptr;
-          return ret;
-        });
-    return mock_insert_context_.get();
-  }
-  std::unique_ptr<MockLookupContext> mock_lookup_context_;
-  std::unique_ptr<MockInsertContext> mock_insert_context_;
-};
-
 } // namespace Cache
 } // namespace HttpFilters
 } // namespace Extensions
diff --git test/extensions/http/cache/file_system_http_cache/file_system_http_cache_test.cc test/extensions/http/cache/file_system_http_cache/file_system_http_cache_test.cc
index 1907643617..29c87ea43a 100644
--- test/extensions/http/cache/file_system_http_cache/file_system_http_cache_test.cc
+++ test/extensions/http/cache/file_system_http_cache/file_system_http_cache_test.cc
@@ -101,6 +101,7 @@ protected:
   std::string cache_path_;
   NiceMock<Server::Configuration::MockFactoryContext> context_;
   std::shared_ptr<FileSystemHttpCache> cache_;
+  LogLevelSetter log_level_ = LogLevelSetter(spdlog::level::debug);
   HttpCacheFactory* http_cache_factory_;
 };
 
-- 
2.51.0


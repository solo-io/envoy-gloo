diff --git a/api/envoy/extensions/matching/common_inputs/network/v3/network_inputs.proto b/api/envoy/extensions/matching/common_inputs/network/v3/network_inputs.proto
index 467771dff6..59756bc0c0 100644
--- api/envoy/extensions/matching/common_inputs/network/v3/network_inputs.proto
+++ api/envoy/extensions/matching/common_inputs/network/v3/network_inputs.proto
@@ -3,6 +3,7 @@ syntax = "proto3";
 package envoy.extensions.matching.common_inputs.network.v3;
 
 import "udpa/annotations/status.proto";
+import "validate/validate.proto";
 
 option java_package = "io.envoyproxy.envoy.extensions.matching.common_inputs.network.v3";
 option java_outer_classname = "NetworkInputsProto";
@@ -95,3 +96,10 @@ message TransportProtocolInput {
 // [#extension: envoy.matching.inputs.application_protocol]
 message ApplicationProtocolInput {
 }
+
+// Input that matches by a specific filter state key.
+// The value of the provided filter state key will be the raw string representation of the filter state object
+// [#extension: envoy.matching.inputs.filter_state]
+message FilterStateInput {
+  string key = 1 [(validate.rules).string = {min_len: 1}];
+}
diff --git a/envoy/network/filter.h b/envoy/network/filter.h
index b7001f9a6c..713fc17450 100644
--- envoy/network/filter.h
+++ envoy/network/filter.h
@@ -570,6 +570,7 @@ public:
   virtual ~MatchingData() = default;
 
   virtual const ConnectionSocket& socket() const PURE;
+  virtual const StreamInfo::FilterState& filterState() const PURE;
 
   const ConnectionInfoProvider& connectionInfoProvider() const {
     return socket().connectionInfoProvider();
diff --git a/source/common/network/matching/data_impl.h b/source/common/network/matching/data_impl.h
index 344ab90476..186bd4b068 100644
--- source/common/network/matching/data_impl.h
+++ source/common/network/matching/data_impl.h
@@ -12,11 +12,15 @@ namespace Matching {
  */
 class MatchingDataImpl : public MatchingData {
 public:
-  explicit MatchingDataImpl(const ConnectionSocket& socket) : socket_(socket) {}
+  explicit MatchingDataImpl(const ConnectionSocket& socket,
+                            const StreamInfo::FilterState& filter_state)
+      : socket_(socket), filter_state_(filter_state) {}
   const ConnectionSocket& socket() const override { return socket_; }
+  const StreamInfo::FilterState& filterState() const override { return filter_state_; }
 
 private:
   const ConnectionSocket& socket_;
+  const StreamInfo::FilterState& filter_state_;
 };
 
 /**
diff --git a/source/common/network/matching/inputs.cc b/source/common/network/matching/inputs.cc
index 15a003ee3b..9c58d1db55 100644
--- source/common/network/matching/inputs.cc
+++ source/common/network/matching/inputs.cc
@@ -27,6 +27,18 @@ Matcher::DataInputGetResult ApplicationProtocolInput::get(const MatchingData& da
   return {Matcher::DataInputGetResult::DataAvailability::AllDataAvailable, absl::nullopt};
 }
 
+Matcher::DataInputGetResult FilterStateInput::get(const MatchingData& data) const {
+  const auto* filter_state_object =
+      data.filterState().getDataReadOnly<StreamInfo::FilterState::Object>(filter_state_key_);
+
+  if (filter_state_object != nullptr) {
+    return {Matcher::DataInputGetResult::DataAvailability::AllDataAvailable,
+            filter_state_object->serializeAsString()};
+  }
+
+  return {Matcher::DataInputGetResult::DataAvailability::AllDataAvailable, absl::nullopt};
+}
+
 class DestinationIPInputFactory : public DestinationIPInputBaseFactory<MatchingData> {};
 class UdpDestinationIPInputFactory : public DestinationIPInputBaseFactory<UdpMatchingData> {};
 class HttpDestinationIPInputFactory : public DestinationIPInputBaseFactory<Http::HttpMatchingData> {
@@ -76,6 +88,7 @@ REGISTER_FACTORY(HttpSourceTypeInputFactory, Matcher::DataInputFactory<Http::Htt
 
 REGISTER_FACTORY(TransportProtocolInputFactory, Matcher::DataInputFactory<MatchingData>);
 REGISTER_FACTORY(ApplicationProtocolInputFactory, Matcher::DataInputFactory<MatchingData>);
+REGISTER_FACTORY(FilterStateInputFactory, Matcher::DataInputFactory<MatchingData>);
 
 } // namespace Matching
 } // namespace Network
diff --git a/source/common/network/matching/inputs.h b/source/common/network/matching/inputs.h
index 0eaac39681..da7932e9ad 100644
--- source/common/network/matching/inputs.h
+++ source/common/network/matching/inputs.h
@@ -268,6 +268,40 @@ public:
 
 DECLARE_FACTORY(ApplicationProtocolInputFactory);
 
+class FilterStateInput : public Matcher::DataInput<MatchingData> {
+public:
+  FilterStateInput(
+      const envoy::extensions::matching::common_inputs::network::v3::FilterStateInput& input_config)
+      : filter_state_key_(input_config.key()) {}
+
+  Matcher::DataInputGetResult get(const MatchingData& data) const override;
+
+private:
+  const std::string filter_state_key_;
+};
+
+class FilterStateInputFactory : public Matcher::DataInputFactory<MatchingData> {
+public:
+  std::string name() const override { return "envoy.matching.inputs.filter_state"; }
+
+  Matcher::DataInputFactoryCb<MatchingData> createDataInputFactoryCb(
+      const Protobuf::Message& message,
+      ProtobufMessage::ValidationVisitor& message_validation_visitor) override {
+    const auto& proto_config = MessageUtil::downcastAndValidate<
+        const envoy::extensions::matching::common_inputs::network::v3::FilterStateInput&>(
+        message, message_validation_visitor);
+
+    return [proto_config]() { return std::make_unique<FilterStateInput>(proto_config); };
+  };
+
+  ProtobufTypes::MessagePtr createEmptyConfigProto() override {
+    return std::make_unique<
+        envoy::extensions::matching::common_inputs::network::v3::FilterStateInput>();
+  }
+};
+
+DECLARE_FACTORY(FilterStateInputFactory);
+
 } // namespace Matching
 } // namespace Network
 } // namespace Envoy
diff --git a/source/extensions/extensions_metadata.yaml b/source/extensions/extensions_metadata.yaml
index 31f424b44d..cfd18e7b86 100644
--- source/extensions/extensions_metadata.yaml
+++ source/extensions/extensions_metadata.yaml
@@ -1316,6 +1316,13 @@ envoy.matching.inputs.application_protocol:
   status: alpha
   type_urls:
   - envoy.extensions.matching.common_inputs.network.v3.ApplicationProtocolInput
+envoy.matching.inputs.filter_state:
+  categories:
+  - envoy.matching.network.input
+  security_posture: unknown
+  status: alpha
+  type_urls:
+  - envoy.extensions.matching.common_inputs.network.v3.FilterStateInput
 envoy.matching.inputs.uri_san:
   categories:
   - envoy.matching.http.input
diff --git a/source/extensions/listener_managers/listener_manager/filter_chain_manager_impl.cc b/source/extensions/listener_managers/listener_manager/filter_chain_manager_impl.cc
index a4ac5b6ac8..cb68dfbda5 100644
--- source/extensions/listener_managers/listener_manager/filter_chain_manager_impl.cc
+++ source/extensions/listener_managers/listener_manager/filter_chain_manager_impl.cc
@@ -585,7 +585,7 @@ FilterChainManagerImpl::findFilterChain(const Network::ConnectionSocket& socket,
 const Network::FilterChain*
 FilterChainManagerImpl::findFilterChainUsingMatcher(const Network::ConnectionSocket& socket,
                                                     const StreamInfo::StreamInfo& info) const {
-  Network::Matching::MatchingDataImpl data(socket);
+  Network::Matching::MatchingDataImpl data(socket, info.filterState());
   const auto& match_result = Matcher::evaluateMatch<Network::MatchingData>(*matcher_, data);
   ASSERT(match_result.match_state_ == Matcher::MatchState::MatchComplete,
          "Matching must complete for network streams.");
diff --git a/test/common/network/matching/BUILD b/test/common/network/matching/BUILD
index e0723d8853..bee7fbea82 100644
--- test/common/network/matching/BUILD
+++ test/common/network/matching/BUILD
@@ -16,6 +16,7 @@ envoy_cc_test(
         "//source/common/network:address_lib",
         "//source/common/network/matching:data_impl_lib",
         "//source/common/network/matching:inputs_lib",
+        "//source/common/router:string_accessor_lib",
         "//test/mocks/network:network_mocks",
     ],
 )
@@ -27,6 +28,7 @@ envoy_cc_test(
         "//source/common/network:address_lib",
         "//source/common/network/matching:data_impl_lib",
         "//source/common/network/matching:inputs_lib",
+        "//source/common/router:string_accessor_lib",
         "//test/common/matcher:test_utility_lib",
         "//test/mocks/matcher:matcher_mocks",
         "//test/mocks/network:network_mocks",
diff --git a/test/common/network/matching/inputs_integration_test.cc b/test/common/network/matching/inputs_integration_test.cc
index f3f9203b89..4669e75886 100644
--- test/common/network/matching/inputs_integration_test.cc
+++ test/common/network/matching/inputs_integration_test.cc
@@ -1,6 +1,8 @@
 #include "source/common/network/address_impl.h"
 #include "source/common/network/matching/data_impl.h"
 #include "source/common/network/matching/inputs.h"
+#include "source/common/router/string_accessor_impl.h"
+#include "source/common/stream_info/filter_state_impl.h"
 
 #include "test/common/matcher/test_utility.h"
 #include "test/mocks/matcher/mocks.h"
@@ -29,6 +31,23 @@ matcher_tree:
             value: foo
 )EOF";
 
+constexpr absl::string_view yaml_filter_state = R"EOF(
+matcher_tree:
+  input:
+    name: input
+    typed_config:
+      "@type": type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.FilterStateInput
+      key: {}
+  exact_match_map:
+    map:
+      "{}":
+        action:
+          name: test_action
+          typed_config:
+            "@type": type.googleapis.com/google.protobuf.StringValue
+            value: foo
+)EOF";
+
 class InputsIntegrationTest : public ::testing::Test {
 public:
   InputsIntegrationTest()
@@ -45,6 +64,14 @@ public:
     match_tree_ = matcher_factory_.create(matcher);
   }
 
+  void initializeFilterStateCase(const std::string& key, const std::string& value) {
+    xds::type::matcher::v3::Matcher matcher;
+    MessageUtil::loadFromYaml(fmt::format(yaml_filter_state, key, value), matcher,
+                              ProtobufMessage::getStrictValidationVisitor());
+
+    match_tree_ = matcher_factory_.create(matcher);
+  }
+
 protected:
   Matcher::StringActionFactory action_factory_;
   Registry::InjectFactory<Matcher::ActionFactory<absl::string_view>> inject_action_;
@@ -59,7 +86,8 @@ TEST_F(InputsIntegrationTest, DestinationIPInput) {
   initialize("DestinationIPInput", "127.0.0.1");
 
   Network::MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
   socket.connection_info_provider_->setLocalAddress(
       std::make_shared<Network::Address::Ipv4Instance>("127.0.0.1", 8080));
 
@@ -72,7 +100,8 @@ TEST_F(InputsIntegrationTest, DestinationPortInput) {
   initialize("DestinationPortInput", "8080");
 
   Network::MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
   socket.connection_info_provider_->setLocalAddress(
       std::make_shared<Network::Address::Ipv4Instance>("127.0.0.1", 8080));
 
@@ -85,7 +114,8 @@ TEST_F(InputsIntegrationTest, SourceIPInput) {
   initialize("SourceIPInput", "127.0.0.1");
 
   Network::MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
   socket.connection_info_provider_->setRemoteAddress(
       std::make_shared<Network::Address::Ipv4Instance>("127.0.0.1", 8080));
 
@@ -98,7 +128,8 @@ TEST_F(InputsIntegrationTest, SourcePortInput) {
   initialize("SourcePortInput", "8080");
 
   Network::MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
   socket.connection_info_provider_->setRemoteAddress(
       std::make_shared<Network::Address::Ipv4Instance>("127.0.0.1", 8080));
 
@@ -111,7 +142,8 @@ TEST_F(InputsIntegrationTest, DirectSourceIPInput) {
   initialize("DirectSourceIPInput", "127.0.0.1");
 
   Network::MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
   socket.connection_info_provider_->setDirectRemoteAddressForTest(
       std::make_shared<Network::Address::Ipv4Instance>("127.0.0.1", 8080));
 
@@ -124,7 +156,8 @@ TEST_F(InputsIntegrationTest, SourceTypeInput) {
   initialize("SourceTypeInput", "local");
 
   Network::MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
   socket.connection_info_provider_->setRemoteAddress(
       std::make_shared<Network::Address::Ipv4Instance>("127.0.0.1", 8080));
 
@@ -138,7 +171,8 @@ TEST_F(InputsIntegrationTest, ServerNameInput) {
   initialize("ServerNameInput", host);
 
   Network::MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
   socket.connection_info_provider_->setRequestedServerName(host);
 
   const auto result = match_tree_()->match(data);
@@ -150,7 +184,8 @@ TEST_F(InputsIntegrationTest, TransportProtocolInput) {
   initialize("TransportProtocolInput", "tls");
 
   Network::MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
   EXPECT_CALL(socket, detectedTransportProtocol).WillOnce(testing::Return("tls"));
 
   const auto result = match_tree_()->match(data);
@@ -162,7 +197,8 @@ TEST_F(InputsIntegrationTest, ApplicationProtocolInput) {
   initialize("ApplicationProtocolInput", "'http/1.1'");
 
   Network::MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
   std::vector<std::string> protocols = {"http/1.1"};
   EXPECT_CALL(socket, requestedApplicationProtocols).WillOnce(testing::ReturnRef(protocols));
 
@@ -171,6 +207,57 @@ TEST_F(InputsIntegrationTest, ApplicationProtocolInput) {
   EXPECT_TRUE(result.on_match_.has_value());
 }
 
+TEST_F(InputsIntegrationTest, FilterStateInput) {
+  std::string key = "filter_state_key";
+  std::string value = "filter_state_value";
+  initializeFilterStateCase(key, value);
+
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  filter_state.setData(key, std::make_shared<Router::StringAccessorImpl>(value),
+                       StreamInfo::FilterState::StateType::Mutable,
+                       StreamInfo::FilterState::LifeSpan::Connection);
+
+  Network::MockConnectionSocket socket;
+  MatchingDataImpl data(socket, filter_state);
+
+  const auto result = match_tree_()->match(data);
+  EXPECT_EQ(result.match_state_, Matcher::MatchState::MatchComplete);
+  EXPECT_TRUE(result.on_match_.has_value());
+}
+
+TEST_F(InputsIntegrationTest, FilterStateInputFailure) {
+  std::string key = "filter_state_key";
+  std::string value = "filter_state_value";
+  initializeFilterStateCase(key, value);
+
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  Network::MockConnectionSocket socket;
+  MatchingDataImpl data(socket, filter_state);
+
+  // No filter state object - no match
+  const auto result_no_fs = match_tree_()->match(data);
+  EXPECT_EQ(result_no_fs.match_state_, Matcher::MatchState::MatchComplete);
+  EXPECT_FALSE(result_no_fs.on_match_.has_value());
+
+  filter_state.setData("unknown_key", std::make_shared<Router::StringAccessorImpl>(value),
+                       StreamInfo::FilterState::StateType::Mutable,
+                       StreamInfo::FilterState::LifeSpan::Connection);
+
+  // Unknown key in filter state - no match
+  const auto result_no_key = match_tree_()->match(data);
+  EXPECT_EQ(result_no_key.match_state_, Matcher::MatchState::MatchComplete);
+  EXPECT_FALSE(result_no_key.on_match_.has_value());
+
+  filter_state.setData(key, std::make_shared<Router::StringAccessorImpl>("unknown_value"),
+                       StreamInfo::FilterState::StateType::Mutable,
+                       StreamInfo::FilterState::LifeSpan::Connection);
+
+  // Known key in filter state but unknown value - no match
+  const auto result_no_value = match_tree_()->match(data);
+  EXPECT_EQ(result_no_value.match_state_, Matcher::MatchState::MatchComplete);
+  EXPECT_FALSE(result_no_value.on_match_.has_value());
+}
+
 class UdpInputsIntegrationTest : public ::testing::Test {
 public:
   UdpInputsIntegrationTest()
diff --git a/test/common/network/matching/inputs_test.cc b/test/common/network/matching/inputs_test.cc
index c673a6220f..42356c1e4f 100644
--- test/common/network/matching/inputs_test.cc
+++ test/common/network/matching/inputs_test.cc
@@ -4,6 +4,8 @@
 #include "source/common/network/address_impl.h"
 #include "source/common/network/matching/data_impl.h"
 #include "source/common/network/matching/inputs.h"
+#include "source/common/router/string_accessor_impl.h"
+#include "source/common/stream_info/filter_state_impl.h"
 
 #include "test/mocks/network/mocks.h"
 
@@ -14,7 +16,8 @@ namespace Matching {
 TEST(MatchingData, DestinationIPInput) {
   DestinationIPInput<MatchingData> input;
   MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
 
   {
     socket.connection_info_provider_->setLocalAddress(
@@ -101,7 +104,8 @@ TEST(MatchingData, HttpDestinationIPInput) {
 TEST(MatchingData, DestinationPortInput) {
   DestinationPortInput<MatchingData> input;
   MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
 
   {
     socket.connection_info_provider_->setLocalAddress(
@@ -125,7 +129,8 @@ TEST(MatchingData, DestinationPortInput) {
 TEST(MatchingData, SourceIPInput) {
   SourceIPInput<MatchingData> input;
   MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
 
   {
     socket.connection_info_provider_->setRemoteAddress(
@@ -149,7 +154,8 @@ TEST(MatchingData, SourceIPInput) {
 TEST(MatchingData, SourcePortInput) {
   SourcePortInput<MatchingData> input;
   MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
 
   {
     socket.connection_info_provider_->setRemoteAddress(
@@ -173,7 +179,8 @@ TEST(MatchingData, SourcePortInput) {
 TEST(MatchingData, DirectSourceIPInput) {
   DirectSourceIPInput<MatchingData> input;
   MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
 
   {
     socket.connection_info_provider_->setDirectRemoteAddressForTest(
@@ -197,7 +204,8 @@ TEST(MatchingData, DirectSourceIPInput) {
 TEST(MatchingData, SourceTypeInput) {
   SourceTypeInput<MatchingData> input;
   MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
 
   {
     socket.connection_info_provider_->setRemoteAddress(
@@ -221,7 +229,8 @@ TEST(MatchingData, SourceTypeInput) {
 TEST(MatchingData, ServerNameInput) {
   ServerNameInput<MatchingData> input;
   MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
 
   {
     const auto result = input.get(data);
@@ -243,7 +252,8 @@ TEST(MatchingData, ServerNameInput) {
 TEST(MatchingData, TransportProtocolInput) {
   TransportProtocolInput input;
   MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
 
   {
     EXPECT_CALL(socket, detectedTransportProtocol).WillOnce(testing::Return(""));
@@ -266,7 +276,8 @@ TEST(MatchingData, TransportProtocolInput) {
 TEST(MatchingData, ApplicationProtocolInput) {
   ApplicationProtocolInput input;
   MockConnectionSocket socket;
-  MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
 
   {
     std::vector<std::string> protocols = {};
@@ -296,6 +307,49 @@ TEST(MatchingData, ApplicationProtocolInput) {
   }
 }
 
+TEST(MatchingData, FilterStateInput) {
+  std::string key = "filter_state_key";
+
+  envoy::extensions::matching::common_inputs::network::v3::FilterStateInput input_config;
+  input_config.set_key(key);
+
+  FilterStateInput input(input_config);
+
+  MockConnectionSocket socket;
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  MatchingDataImpl data(socket, filter_state);
+
+  {
+    const auto result = input.get(data);
+    EXPECT_EQ(result.data_availability_,
+              Matcher::DataInputGetResult::DataAvailability::AllDataAvailable);
+    EXPECT_EQ(result.data_, absl::nullopt);
+  }
+
+  filter_state.setData("unknown_key", std::make_shared<Router::StringAccessorImpl>("some_value"),
+                       StreamInfo::FilterState::StateType::Mutable,
+                       StreamInfo::FilterState::LifeSpan::Connection);
+
+  {
+    const auto result = input.get(data);
+    EXPECT_EQ(result.data_availability_,
+              Matcher::DataInputGetResult::DataAvailability::AllDataAvailable);
+    EXPECT_EQ(result.data_, absl::nullopt);
+  }
+
+  std::string value = "filter_state_value";
+  filter_state.setData(key, std::make_shared<Router::StringAccessorImpl>(value),
+                       StreamInfo::FilterState::StateType::Mutable,
+                       StreamInfo::FilterState::LifeSpan::Connection);
+
+  {
+    const auto result = input.get(data);
+    EXPECT_EQ(result.data_availability_,
+              Matcher::DataInputGetResult::DataAvailability::AllDataAvailable);
+    EXPECT_EQ(result.data_, value);
+  }
+}
+
 TEST(UdpMatchingData, UdpDestinationIPInput) {
   DestinationIPInput<UdpMatchingData> input;
   const Address::Ipv4Instance ip("127.0.0.1", 8080);
diff --git a/test/common/ssl/matching/inputs_integration_test.cc b/test/common/ssl/matching/inputs_integration_test.cc
index 99439ca9f8..8e5d58bf33 100644
--- test/common/ssl/matching/inputs_integration_test.cc
+++ test/common/ssl/matching/inputs_integration_test.cc
@@ -69,7 +69,8 @@ TEST_F(NetworkInputsIntegrationTest, UriSanInput) {
   socket.connection_info_provider_->setSslConnection(ssl);
   std::vector<std::string> uri_sans{host};
   EXPECT_CALL(*ssl, uriSanPeerCertificate()).WillOnce(Return(uri_sans));
-  Network::Matching::MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  Network::Matching::MatchingDataImpl data(socket, filter_state);
 
   const auto result = match_tree_()->match(data);
   EXPECT_EQ(result.match_state_, Matcher::MatchState::MatchComplete);
@@ -86,7 +87,8 @@ TEST_F(NetworkInputsIntegrationTest, DnsSanInput) {
   socket.connection_info_provider_->setSslConnection(ssl);
   std::vector<std::string> dns_sans{host};
   EXPECT_CALL(*ssl, dnsSansPeerCertificate()).WillOnce(Return(dns_sans));
-  Network::Matching::MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  Network::Matching::MatchingDataImpl data(socket, filter_state);
 
   const auto result = match_tree_()->match(data);
   EXPECT_EQ(result.match_state_, Matcher::MatchState::MatchComplete);
@@ -102,7 +104,8 @@ TEST_F(NetworkInputsIntegrationTest, SubjectInput) {
   std::shared_ptr<Ssl::MockConnectionInfo> ssl = std::make_shared<Ssl::MockConnectionInfo>();
   socket.connection_info_provider_->setSslConnection(ssl);
   EXPECT_CALL(*ssl, subjectPeerCertificate()).WillOnce(testing::ReturnRef(host));
-  Network::Matching::MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  Network::Matching::MatchingDataImpl data(socket, filter_state);
 
   const auto result = match_tree_()->match(data);
   EXPECT_EQ(result.match_state_, Matcher::MatchState::MatchComplete);
diff --git a/test/extensions/common/matcher/trie_matcher_test.cc b/test/extensions/common/matcher/trie_matcher_test.cc
index 1d1e9dc92f..53798d92d2 100644
--- test/extensions/common/matcher/trie_matcher_test.cc
+++ test/extensions/common/matcher/trie_matcher_test.cc
@@ -535,7 +535,8 @@ matcher_tree:
   Network::MockConnectionSocket socket;
   socket.connection_info_provider_->setLocalAddress(
       std::make_shared<Network::Address::Ipv4Instance>("192.168.0.1", 8080));
-  Network::Matching::MatchingDataImpl data(socket);
+  StreamInfo::FilterStateImpl filter_state(StreamInfo::FilterState::LifeSpan::Connection);
+  Network::Matching::MatchingDataImpl data(socket, filter_state);
 
   const auto result = match_tree()->match(data);
   EXPECT_EQ(result.match_state_, MatchState::MatchComplete);
diff --git a/test/extensions/listener_managers/listener_manager/BUILD b/test/extensions/listener_managers/listener_manager/BUILD
index bc274c67de..d333eeb617 100644
--- test/extensions/listener_managers/listener_manager/BUILD
+++ test/extensions/listener_managers/listener_manager/BUILD
@@ -52,6 +52,7 @@ envoy_cc_test(
         "//source/common/network:socket_option_lib",
         "//source/common/network:utility_lib",
         "//source/common/protobuf",
+        "//source/common/router:string_accessor_lib",
         "//source/extensions/filters/listener/original_dst:config",
         "//source/extensions/filters/listener/proxy_protocol:config",
         "//source/extensions/filters/listener/tls_inspector:config",
diff --git a/test/extensions/listener_managers/listener_manager/listener_manager_impl_test.cc b/test/extensions/listener_managers/listener_manager/listener_manager_impl_test.cc
index 7e4dd29914..7f05064a17 100644
--- test/extensions/listener_managers/listener_manager/listener_manager_impl_test.cc
+++ test/extensions/listener_managers/listener_manager/listener_manager_impl_test.cc
@@ -23,6 +23,7 @@
 #include "source/common/network/socket_interface_impl.h"
 #include "source/common/network/utility.h"
 #include "source/common/protobuf/protobuf.h"
+#include "source/common/router/string_accessor_impl.h"
 #include "source/extensions/common/matcher/trie_matcher.h"
 #include "source/extensions/filters/listener/original_dst/original_dst.h"
 #include "source/extensions/filters/listener/tls_inspector/tls_inspector.h"
@@ -3837,6 +3838,72 @@ TEST_P(ListenerManagerImplWithRealFiltersTest, SingleFilterChainWithTransportPro
   EXPECT_EQ(server_names.front(), "server1.example.com");
 }
 
+TEST_P(ListenerManagerImplWithRealFiltersTest, SingleFilterChainWithFilterStateMatch) {
+  if (!use_matcher_) {
+    return;
+  }
+
+  std::string yaml = R"EOF(
+    address:
+      socket_address: { address: 127.0.0.1, port_value: 1234 }
+    listener_filters:
+    - name: "envoy.filters.listener.test"
+      typed_config:
+        "@type": type.googleapis.com/test.integration.filters.TestInspectorFilterConfig
+    filter_chains:
+    - name: foo
+    filter_chain_matcher:
+      matcher_tree:
+        input:
+          name: filter_state
+          typed_config:
+            "@type": type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.FilterStateInput
+            key: filter_state_key
+        exact_match_map:
+          map:
+            "filter_state_value":
+              action:
+                name: foo
+                typed_config:
+                  "@type": type.googleapis.com/google.protobuf.StringValue
+                  value: foo
+    )EOF";
+
+  EXPECT_CALL(server_.api_.random_, uuid());
+  EXPECT_CALL(listener_factory_, createListenSocket(_, _, _, default_bind_type, _, 0));
+  addOrUpdateListener(parseListenerFromV3Yaml(yaml));
+  EXPECT_EQ(1U, manager_->listeners().size());
+
+  // No filter state value set - no match.
+  auto filter_chain = findFilterChain(1234, "127.0.0.1", "", "", {}, "8.8.8.8", 111);
+  EXPECT_EQ(filter_chain, nullptr);
+
+  stream_info_.filterState()->setData(
+      "unknown_key", std::make_shared<Router::StringAccessorImpl>("unknown_value"),
+      StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);
+
+  // Filter state set to a non-matching key - no match.
+  filter_chain = findFilterChain(1234, "127.0.0.1", "", "", {}, "8.8.8.8", 111);
+  EXPECT_EQ(filter_chain, nullptr);
+
+  stream_info_.filterState()->setData(
+      "filter_state_key", std::make_shared<Router::StringAccessorImpl>("unknown_value"),
+      StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);
+
+  // Filter state set to a matching key but unknown value - no match.
+  filter_chain = findFilterChain(1234, "127.0.0.1", "", "", {}, "8.8.8.8", 111);
+  EXPECT_EQ(filter_chain, nullptr);
+
+  stream_info_.filterState()->setData(
+      "filter_state_key", std::make_shared<Router::StringAccessorImpl>("filter_state_value"),
+      StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);
+
+  // Known filter state key and matching value - using 1st filter chain.
+  filter_chain = findFilterChain(1234, "127.0.0.1", "", "", {}, "8.8.8.8", 111);
+  ASSERT_NE(filter_chain, nullptr);
+  EXPECT_EQ(filter_chain->name(), "foo");
+}
+
 TEST_P(ListenerManagerImplWithRealFiltersTest, SingleFilterChainWithApplicationProtocolMatch) {
   std::string yaml = TestEnvironment::substitute(R"EOF(
     address:
@@ -4912,6 +4979,82 @@ TEST_P(ListenerManagerImplWithRealFiltersTest, MultipleFilterChainsWithTransport
   EXPECT_EQ(server_names.front(), "server1.example.com");
 }
 
+TEST_P(ListenerManagerImplWithRealFiltersTest, MultipleFilterChainsWithFilterStateMatch) {
+  if (!use_matcher_) {
+    return;
+  }
+
+  std::string yaml = R"EOF(
+    address:
+      socket_address: { address: 127.0.0.1, port_value: 1234 }
+    listener_filters:
+    - name: "envoy.filters.listener.test"
+      typed_config:
+        "@type": type.googleapis.com/test.integration.filters.TestInspectorFilterConfig
+    filter_chains:
+    - name: foo
+    - name: bar
+    filter_chain_matcher:
+      matcher_tree:
+        input:
+          name: filter_state
+          typed_config:
+            "@type": type.googleapis.com/envoy.extensions.matching.common_inputs.network.v3.FilterStateInput
+            key: filter_state_key
+        exact_match_map:
+          map:
+            "filter_state_value":
+              action:
+                name: bar
+                typed_config:
+                  "@type": type.googleapis.com/google.protobuf.StringValue
+                  value: bar
+      on_no_match:
+        action:
+          name: foo
+          typed_config:
+            "@type": type.googleapis.com/google.protobuf.StringValue
+            value: foo
+    )EOF";
+
+  EXPECT_CALL(server_.api_.random_, uuid());
+  EXPECT_CALL(listener_factory_, createListenSocket(_, _, _, default_bind_type, _, 0));
+  addOrUpdateListener(parseListenerFromV3Yaml(yaml));
+  EXPECT_EQ(1U, manager_->listeners().size());
+
+  // No filter state value set - match foo.
+  auto filter_chain = findFilterChain(1234, "127.0.0.1", "", "", {}, "8.8.8.8", 111);
+  ASSERT_NE(filter_chain, nullptr);
+  EXPECT_EQ(filter_chain->name(), "foo");
+
+  stream_info_.filterState()->setData(
+      "unknown_key", std::make_shared<Router::StringAccessorImpl>("unknown_value"),
+      StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);
+
+  // Filter state set to a non-matching key - no match.
+  filter_chain = findFilterChain(1234, "127.0.0.1", "", "", {}, "8.8.8.8", 111);
+  ASSERT_NE(filter_chain, nullptr);
+  EXPECT_EQ(filter_chain->name(), "foo");
+
+  stream_info_.filterState()->setData(
+      "filter_state_key", std::make_shared<Router::StringAccessorImpl>("unknown_value"),
+      StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);
+
+  // Filter state set to a matching key but unknown value - no match.
+  filter_chain = findFilterChain(1234, "127.0.0.1", "", "", {}, "8.8.8.8", 111);
+  ASSERT_NE(filter_chain, nullptr);
+  EXPECT_EQ(filter_chain->name(), "foo");
+
+  stream_info_.filterState()->setData(
+      "filter_state_key", std::make_shared<Router::StringAccessorImpl>("filter_state_value"),
+      StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);
+
+  // Known filter state key and matching value - using 1st filter chain.
+  filter_chain = findFilterChain(1234, "127.0.0.1", "", "", {}, "8.8.8.8", 111);
+  ASSERT_NE(filter_chain, nullptr);
+  EXPECT_EQ(filter_chain->name(), "bar");
+}
+
 TEST_P(ListenerManagerImplWithRealFiltersTest, MultipleFilterChainsWithApplicationProtocolMatch) {
   std::string yaml = TestEnvironment::substitute(R"EOF(
     address:
diff --git a/test/extensions/listener_managers/listener_manager/listener_manager_impl_test.h b/test/extensions/listener_managers/listener_manager/listener_manager_impl_test.h
index 88fa6c33a1..df3cbccc49 100644
--- test/extensions/listener_managers/listener_manager/listener_manager_impl_test.h
+++ test/extensions/listener_managers/listener_manager/listener_manager_impl_test.h
@@ -236,10 +236,9 @@ protected:
           Network::Utility::parseInternetAddress(direct_source_address, source_port);
     }
     socket_->connection_info_provider_->setDirectRemoteAddressForTest(direct_remote_address_);
-    NiceMock<StreamInfo::MockStreamInfo> stream_info;
 
     return manager_->listeners().back().get().filterChainManager().findFilterChain(*socket_,
-                                                                                   stream_info);
+                                                                                   stream_info_);
   }
 
   /**
@@ -498,6 +497,7 @@ protected:
   Network::Address::InstanceConstSharedPtr local_address_;
   Network::Address::InstanceConstSharedPtr remote_address_;
   Network::Address::InstanceConstSharedPtr direct_remote_address_;
+  NiceMock<StreamInfo::MockStreamInfo> stream_info_;
   std::unique_ptr<Network::MockConnectionSocket> socket_;
   uint64_t listener_tag_{1};
   bool enable_dispatcher_stats_{false};
diff --git a/tools/extensions/extensions_schema.yaml b/tools/extensions/extensions_schema.yaml
index 3c7625be55..b894d8ce57 100644
--- tools/extensions/extensions_schema.yaml
+++ tools/extensions/extensions_schema.yaml
@@ -19,6 +19,7 @@ builtin:
 - envoy.matching.inputs.server_name
 - envoy.matching.inputs.transport_protocol
 - envoy.matching.inputs.application_protocol
+- envoy.matching.inputs.filter_state
 - envoy.matching.inputs.uri_san
 - envoy.matching.inputs.dns_san
 - envoy.matching.inputs.subject

diff --git a/include/inja/environment.hpp b/include/inja/environment.hpp
index 01b7899..014485c 100644
--- include/inja/environment.hpp
+++ include/inja/environment.hpp
@@ -104,14 +104,14 @@ public:
   }

   Template parse(std::string_view input) {
-    Parser parser(parser_config, lexer_config, template_storage, function_storage);
-    return parser.parse(input, input_path);
+    auto parser = std::make_unique<Parser>(parser_config, lexer_config, template_storage, function_storage);
+    return parser->parse(input, input_path);
   }

   Template parse_template(const std::string& filename) {
-    Parser parser(parser_config, lexer_config, template_storage, function_storage);
-    auto result = Template(parser.load_file(input_path + static_cast<std::string>(filename)));
-    parser.parse_into_template(result, input_path + static_cast<std::string>(filename));
+    auto parser = std::make_unique<Parser>(parser_config, lexer_config, template_storage, function_storage);
+    auto result = Template(parser->load_file(input_path + static_cast<std::string>(filename)));
+    parser->parse_into_template(result, input_path + static_cast<std::string>(filename));
     return result;
   }

diff --git a/single_include/inja/inja.hpp b/single_include/inja/inja.hpp
index 8d978c2..68a448c 100644
--- single_include/inja/inja.hpp
+++ single_include/inja/inja.hpp
@@ -2153,7 +2153,11 @@ class Renderer : public NodeVisitor {
     if (value->is_string()) {
       std::string val;
       if (config.escape_strings) {
+        // get the value as a dump() to properly escape values
         val = value->dump();
+
+        // strip the leading and trailing " characters that are added by dump()
+        // if C++20 is adopted, val.starts_with and val.ends_with would clean this up a bit
         val = val.substr(0,1) == "\"" && val.substr(val.length()-1,1) == "\""
             ? val.substr(1, val.length()-2)
             : val;
@@ -2829,14 +2833,14 @@ public:
   }

   Template parse(std::string_view input) {
-    Parser parser(parser_config, lexer_config, template_storage, function_storage);
-    return parser.parse(input, input_path);
+    auto parser = std::make_unique<Parser>(parser_config, lexer_config, template_storage, function_storage);
+    return parser->parse(input, input_path);
   }

   Template parse_template(const std::string& filename) {
-    Parser parser(parser_config, lexer_config, template_storage, function_storage);
-    auto result = Template(parser.load_file(input_path + static_cast<std::string>(filename)));
-    parser.parse_into_template(result, input_path + static_cast<std::string>(filename));
+    auto parser = std::make_unique<Parser>(parser_config, lexer_config, template_storage, function_storage);
+    auto result = Template(parser->load_file(input_path + static_cast<std::string>(filename)));
+    parser->parse_into_template(result, input_path + static_cast<std::string>(filename));
     return result;
   }


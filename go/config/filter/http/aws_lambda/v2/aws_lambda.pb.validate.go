//go:build !disable_pgv
// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/envoy/config/filter/http/aws_lambda/v2/aws_lambda.proto

package v2

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on AWSLambdaPerRoute with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AWSLambdaPerRoute) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AWSLambdaPerRoute with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AWSLambdaPerRouteMultiError, or nil if none found.
func (m *AWSLambdaPerRoute) ValidateAll() error {
	return m.validate(true)
}

func (m *AWSLambdaPerRoute) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetName()) < 1 {
		err := AWSLambdaPerRouteValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Qualifier

	// no validation rules for Async

	if all {
		switch v := interface{}(m.GetEmptyBodyOverride()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AWSLambdaPerRouteValidationError{
					field:  "EmptyBodyOverride",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AWSLambdaPerRouteValidationError{
					field:  "EmptyBodyOverride",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEmptyBodyOverride()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AWSLambdaPerRouteValidationError{
				field:  "EmptyBodyOverride",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UnwrapAsAlb

	if all {
		switch v := interface{}(m.GetTransformerConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AWSLambdaPerRouteValidationError{
					field:  "TransformerConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AWSLambdaPerRouteValidationError{
					field:  "TransformerConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransformerConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AWSLambdaPerRouteValidationError{
				field:  "TransformerConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestTransformerConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AWSLambdaPerRouteValidationError{
					field:  "RequestTransformerConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AWSLambdaPerRouteValidationError{
					field:  "RequestTransformerConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestTransformerConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AWSLambdaPerRouteValidationError{
				field:  "RequestTransformerConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AWSLambdaPerRouteMultiError(errors)
	}

	return nil
}

// AWSLambdaPerRouteMultiError is an error wrapping multiple validation errors
// returned by AWSLambdaPerRoute.ValidateAll() if the designated constraints
// aren't met.
type AWSLambdaPerRouteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AWSLambdaPerRouteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AWSLambdaPerRouteMultiError) AllErrors() []error { return m }

// AWSLambdaPerRouteValidationError is the validation error returned by
// AWSLambdaPerRoute.Validate if the designated constraints aren't met.
type AWSLambdaPerRouteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AWSLambdaPerRouteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AWSLambdaPerRouteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AWSLambdaPerRouteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AWSLambdaPerRouteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AWSLambdaPerRouteValidationError) ErrorName() string {
	return "AWSLambdaPerRouteValidationError"
}

// Error satisfies the builtin error interface
func (e AWSLambdaPerRouteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAWSLambdaPerRoute.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AWSLambdaPerRouteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AWSLambdaPerRouteValidationError{}

// Validate checks the field values on AWSLambdaProtocolExtension with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AWSLambdaProtocolExtension) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AWSLambdaProtocolExtension with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AWSLambdaProtocolExtensionMultiError, or nil if none found.
func (m *AWSLambdaProtocolExtension) ValidateAll() error {
	return m.validate(true)
}

func (m *AWSLambdaProtocolExtension) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetHost()) < 1 {
		err := AWSLambdaProtocolExtensionValidationError{
			field:  "Host",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRegion()) < 1 {
		err := AWSLambdaProtocolExtensionValidationError{
			field:  "Region",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for AccessKey

	// no validation rules for SecretKey

	// no validation rules for SessionToken

	// no validation rules for RoleArn

	// no validation rules for DisableRoleChaining

	if len(errors) > 0 {
		return AWSLambdaProtocolExtensionMultiError(errors)
	}

	return nil
}

// AWSLambdaProtocolExtensionMultiError is an error wrapping multiple
// validation errors returned by AWSLambdaProtocolExtension.ValidateAll() if
// the designated constraints aren't met.
type AWSLambdaProtocolExtensionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AWSLambdaProtocolExtensionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AWSLambdaProtocolExtensionMultiError) AllErrors() []error { return m }

// AWSLambdaProtocolExtensionValidationError is the validation error returned
// by AWSLambdaProtocolExtension.Validate if the designated constraints aren't met.
type AWSLambdaProtocolExtensionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AWSLambdaProtocolExtensionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AWSLambdaProtocolExtensionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AWSLambdaProtocolExtensionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AWSLambdaProtocolExtensionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AWSLambdaProtocolExtensionValidationError) ErrorName() string {
	return "AWSLambdaProtocolExtensionValidationError"
}

// Error satisfies the builtin error interface
func (e AWSLambdaProtocolExtensionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAWSLambdaProtocolExtension.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AWSLambdaProtocolExtensionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AWSLambdaProtocolExtensionValidationError{}

// Validate checks the field values on AWSLambdaConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AWSLambdaConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AWSLambdaConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AWSLambdaConfigMultiError, or nil if none found.
func (m *AWSLambdaConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AWSLambdaConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PropagateOriginalRouting

	if all {
		switch v := interface{}(m.GetCredentialRefreshDelay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AWSLambdaConfigValidationError{
					field:  "CredentialRefreshDelay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AWSLambdaConfigValidationError{
					field:  "CredentialRefreshDelay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCredentialRefreshDelay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AWSLambdaConfigValidationError{
				field:  "CredentialRefreshDelay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.CredentialsFetcher.(type) {
	case *AWSLambdaConfig_UseDefaultCredentials:
		if v == nil {
			err := AWSLambdaConfigValidationError{
				field:  "CredentialsFetcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUseDefaultCredentials()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AWSLambdaConfigValidationError{
						field:  "UseDefaultCredentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AWSLambdaConfigValidationError{
						field:  "UseDefaultCredentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUseDefaultCredentials()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AWSLambdaConfigValidationError{
					field:  "UseDefaultCredentials",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AWSLambdaConfig_ServiceAccountCredentials_:
		if v == nil {
			err := AWSLambdaConfigValidationError{
				field:  "CredentialsFetcher",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServiceAccountCredentials()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AWSLambdaConfigValidationError{
						field:  "ServiceAccountCredentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AWSLambdaConfigValidationError{
						field:  "ServiceAccountCredentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServiceAccountCredentials()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AWSLambdaConfigValidationError{
					field:  "ServiceAccountCredentials",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AWSLambdaConfigMultiError(errors)
	}

	return nil
}

// AWSLambdaConfigMultiError is an error wrapping multiple validation errors
// returned by AWSLambdaConfig.ValidateAll() if the designated constraints
// aren't met.
type AWSLambdaConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AWSLambdaConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AWSLambdaConfigMultiError) AllErrors() []error { return m }

// AWSLambdaConfigValidationError is the validation error returned by
// AWSLambdaConfig.Validate if the designated constraints aren't met.
type AWSLambdaConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AWSLambdaConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AWSLambdaConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AWSLambdaConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AWSLambdaConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AWSLambdaConfigValidationError) ErrorName() string { return "AWSLambdaConfigValidationError" }

// Error satisfies the builtin error interface
func (e AWSLambdaConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAWSLambdaConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AWSLambdaConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AWSLambdaConfigValidationError{}

// Validate checks the field values on
// AWSLambdaConfig_ServiceAccountCredentials with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AWSLambdaConfig_ServiceAccountCredentials) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// AWSLambdaConfig_ServiceAccountCredentials with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// AWSLambdaConfig_ServiceAccountCredentialsMultiError, or nil if none found.
func (m *AWSLambdaConfig_ServiceAccountCredentials) ValidateAll() error {
	return m.validate(true)
}

func (m *AWSLambdaConfig_ServiceAccountCredentials) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetCluster()) < 1 {
		err := AWSLambdaConfig_ServiceAccountCredentialsValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetUri()) < 1 {
		err := AWSLambdaConfig_ServiceAccountCredentialsValidationError{
			field:  "Uri",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AWSLambdaConfig_ServiceAccountCredentialsValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AWSLambdaConfig_ServiceAccountCredentialsValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AWSLambdaConfig_ServiceAccountCredentialsValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Region

	if len(errors) > 0 {
		return AWSLambdaConfig_ServiceAccountCredentialsMultiError(errors)
	}

	return nil
}

// AWSLambdaConfig_ServiceAccountCredentialsMultiError is an error wrapping
// multiple validation errors returned by
// AWSLambdaConfig_ServiceAccountCredentials.ValidateAll() if the designated
// constraints aren't met.
type AWSLambdaConfig_ServiceAccountCredentialsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AWSLambdaConfig_ServiceAccountCredentialsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AWSLambdaConfig_ServiceAccountCredentialsMultiError) AllErrors() []error { return m }

// AWSLambdaConfig_ServiceAccountCredentialsValidationError is the validation
// error returned by AWSLambdaConfig_ServiceAccountCredentials.Validate if the
// designated constraints aren't met.
type AWSLambdaConfig_ServiceAccountCredentialsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AWSLambdaConfig_ServiceAccountCredentialsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AWSLambdaConfig_ServiceAccountCredentialsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AWSLambdaConfig_ServiceAccountCredentialsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AWSLambdaConfig_ServiceAccountCredentialsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AWSLambdaConfig_ServiceAccountCredentialsValidationError) ErrorName() string {
	return "AWSLambdaConfig_ServiceAccountCredentialsValidationError"
}

// Error satisfies the builtin error interface
func (e AWSLambdaConfig_ServiceAccountCredentialsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAWSLambdaConfig_ServiceAccountCredentials.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AWSLambdaConfig_ServiceAccountCredentialsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AWSLambdaConfig_ServiceAccountCredentialsValidationError{}
